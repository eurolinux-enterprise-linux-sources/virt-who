diff --git a/rel-eng/packages/virt-who b/rel-eng/packages/virt-who
index c9a61c2..95639c1 100644
--- a/rel-eng/packages/virt-who
+++ b/rel-eng/packages/virt-who
@@ -1 +1 @@
-0.18-4 ./
+0.18-5 ./
diff --git a/tests/test_virtwho.py b/tests/test_virtwho.py
index 43b8951..2f2f47e 100644
--- a/tests/test_virtwho.py
+++ b/tests/test_virtwho.py
@@ -370,7 +370,7 @@ class TestSend(TestBase):
         options.log_dir = ''
         options.log_file = ''
         virtwho = Executor(Mock(), options, config_dir="/nonexistant")
-        virtwho.oneshot_remaining = ['config_name']
+        virtwho.oneshot_remaining = set(['config_name'])
 
         def check_report_state(report):
             report.state = AbstractVirtReport.STATE_FINISHED
@@ -390,10 +390,10 @@ class TestSend(TestBase):
 
         virtwho.send_current_report()
 
-        virtwho.check_report_state(virtwho.report_in_progress)
+        virtwho.check_report_state(virtwho.reports_in_progress.items()[0][1])
 
         virtwho.send.assert_called_with(report)
-        self.assertEquals(virtwho.send_after, initial + MinimumSendInterval)
+        self.assertEquals(virtwho.send_after, initial + options.interval)
 
     @patch('time.time')
     @patch('virtwho.log.getLogger')
@@ -435,7 +435,7 @@ class TestSend(TestBase):
         virtwho.send.side_effect = ManagerThrottleError(retry_after)
         virtwho.send_current_report()
         virtwho.send.assert_called_with(report)
-        self.assertEquals(virtwho.send_after, initial + retry_after * 2)
+        self.assertEquals(virtwho.send_after, initial + retry_after)
         self.assertEquals(len(virtwho.queued_reports), 1)
 
         def finish(x):
@@ -443,9 +443,7 @@ class TestSend(TestBase):
             return True
         virtwho.send.side_effect = finish
         virtwho.send_current_report()
-        retry_after = 60
-        self.assertEquals(virtwho.retry_after, retry_after)
-        self.assertEquals(virtwho.send_after, initial + MinimumSendInterval)
+        self.assertEquals(virtwho.send_after, initial + options.interval)
         self.assertEquals(len(virtwho.queued_reports), 0)
 
 
diff --git a/virt-who.spec b/virt-who.spec
index a6dce7b..a827547 100644
--- a/virt-who.spec
+++ b/virt-who.spec
@@ -6,7 +6,7 @@
 
 Name:           virt-who
 Version:        0.18
-Release:        4%{?dist}
+Release:        5%{?dist}
 Summary:        Agent for reporting virtual guest IDs to subscription-manager
 
 Group:          System Environment/Base
@@ -127,6 +127,9 @@ fi
 
 
 %changelog
+* Thu Nov 02 2017 Christopher Snyder <csnyder@redhat.com> 0.18-5
+- 1507786: Modification of the job polling frequency (csnyder@redhat.com)
+
 * Wed Nov 01 2017 Christopher Snyder <csnyder@redhat.com> 0.18-4
 - 1507786: Updates to the job polling frequency (csnyder@redhat.com)
 
diff --git a/virtwho/executor.py b/virtwho/executor.py
index c47bf2e..c46613b 100644
--- a/virtwho/executor.py
+++ b/virtwho/executor.py
@@ -50,6 +50,8 @@ class Executor(object):
         # received between successfully sent reports
         self._429_count = 0
         self.reloading = False
+        # The last time a 429 was returned from the server
+        self.last_429_time = 0
 
         # Reports that are queued for sending
         self.queued_reports = OrderedDict()
@@ -58,7 +60,7 @@ class Executor(object):
         self.oneshot_remaining = set()
 
         # Report that is currently being processed by server
-        self.report_in_progress = None
+        self.reports_in_progress = OrderedDict()
 
         # True if this is the first time we are checking job status for a given job
         self.is_first_job_check = True
@@ -87,7 +89,7 @@ class Executor(object):
 
     def _is_next_job_check_time(self):
         # If there are no jobs to check, it's not time to check them
-        if not self.report_in_progress:
+        if not self.reports_in_progress:
             return False
         return time.time() >= self.next_job_status_check
 
@@ -95,18 +97,26 @@ class Executor(object):
         name, report = self.queued_reports.popitem(last=False)
         return self.send_report(name, report)
 
+    def _handle_429(self, retry_after):
+        self._429_count += 1
+        self.retry_after = retry_after
+        self.last_429_time = time.time()
+        self.logger.debug('429 received, waiting %s seconds until sending again', self.retry_after)
+
+    def _reset_429_handler(self):
+        self._429_count = 0
+        self.retry_after = 0
+        self.last_429_time = 0
+
     def send_report(self, name, report):
         try:
             if self.send(report):
-                # Success will reset the 429 count
-                if self._429_count > 0:
-                    self._429_count = 1
-                    self.retry_after = MinimumSendInterval
-
                 self.logger.debug('Report for config "%s" sent', name)
                 if report.state == AbstractVirtReport.STATE_PROCESSING:
-                    self.report_in_progress = report
-                    self.next_job_status_check = time.time() + MinimumJobPollInterval
+                    if not self.reports_in_progress:
+                        self.next_job_status_check = time.time() + MinimumJobPollInterval
+                    self.reports_in_progress[report.config.name] = report
+
                 else:
                     self.report_done(report)
             else:
@@ -115,32 +125,26 @@ class Executor(object):
                 self.report_done(report)
         except ManagerThrottleError as e:
             self.queued_reports[name] = report
-            self._429_count += 1
-            self.retry_after = max(MinimumSendInterval, e.retry_after * self._429_count)
+            self._handle_429(max(MinimumSendInterval, e.retry_after))
             self.send_after = time.time() + self.retry_after
-            self.logger.debug('429 received, waiting %s seconds until sending again', self.retry_after)
 
     def report_done(self, report):
         name = report.config.name
-        if self.options.oneshot:
-            self.send_after = time.time() + self.retry_after
-        else:
-            self.send_after = time.time() + self.options.interval
+        self.send_after = time.time() + self.options.interval
         if report.state == AbstractVirtReport.STATE_FINISHED:
             self.last_reports_hash[name] = report.hash
 
         if report.state in [AbstractVirtReport.STATE_FINISHED,
                             AbstractVirtReport.STATE_FAILED,
                             AbstractVirtReport.STATE_CANCELED]:
-            self.report_in_progress = None
-            self.next_job_status_check = 0
+            if name in self.reports_in_progress:
+                del self.reports_in_progress[name]
+            if self.reports_in_progress:
+                self.next_job_status_check = time.time() + MinimumJobPollInterval
             self.is_first_job_check = True
 
         if self.options.oneshot:
-            try:
-                self.oneshot_remaining.remove(name)
-            except KeyError:
-                pass
+            self.oneshot_remaining.discard(name)
 
     def send(self, report):
         """
@@ -224,7 +228,7 @@ class Executor(object):
         self.last_reports_hash.clear()
 
         # report that is being processed by the server
-        self.report_in_progress = None
+        self.reports_in_progress.clear()
 
         # Send the first report immediately
         self.send_after = time.time()
@@ -237,9 +241,9 @@ class Executor(object):
         while not self.terminate_event.is_set():
             # Block for the amount of time closest to the next action we need to perform
             # OR do not block at all if it is time to do one of them
-            timeout = max(1, min(self.next_job_status_check - time.time(),
-                                 self.send_after - time.time()))
-            if self.oneshot_remaining:
+            timeout = max(self.retry_after - (time.time() - self.last_429_time),
+                          min(self.next_job_status_check - time.time(), self.send_after - time.time()))
+            if (self.oneshot_remaining and self._429_count < 1) or timeout < 0:
                 timeout = 1
             # Wait for incoming report from virt backend or for timeout
             try:
@@ -255,16 +259,17 @@ class Executor(object):
                 if isinstance(report, ErrorReport):
                     if self.options.oneshot:
                         # Don't hang on the failed backend
-                        try:
-                            self.oneshot_remaining.remove(report.config.name)
-                        except KeyError:
-                            pass
+                        self.oneshot_remaining.discard(report.config.name)
                         self.logger.warn('Unable to collect report for config "%s"', report.config.name)
                 elif isinstance(report, AbstractVirtReport):
                     if self.last_reports_hash.get(report.config.name, None) != report.hash:
                         self.queued_reports[report.config.name] = report
                         if report.config.name in self.oneshot_remaining:
-                            self.oneshot_remaining.remove(report.config.name)
+                            if not self.options.print_:
+                                # Report is not queued if it sent immediately
+                                del self.queued_reports[report.config.name]
+                                self.send_report(report.config.name, report)
+                            self.oneshot_remaining.discard(report.config.name)
                     else:
                         self.logger.info('Report for config "%s" hasn\'t changed, not sending', report.config.name)
                 elif report in ['exit', 'reload']:
@@ -284,26 +289,32 @@ class Executor(object):
                 self.stop_virts()
                 raise ReloadRequest()
 
+            if time.time() < (self.last_429_time + self.retry_after):
+                continue
+            else:
+                self._reset_429_handler()
+
             if self._is_next_job_check_time():
                 try:
-                    report_state = self.check_report_state(self.report_in_progress)
+                    report_state = self.check_report_state(self.reports_in_progress.items()[0][1])
                 except ManagerThrottleError as e:
                     self.logger.debug('HTTP 429 received during job polling')
-                    if e.retry_after != 0:
-                        self.next_job_status_check = time.time() + e.retry_after
+                    retry_after = e.retry_after if e.retry_after != 0 else (MinimumJobPollInterval * 2)
+                    self.next_job_status_check = time.time() + retry_after
+                    self._handle_429(retry_after)
                 else:
+                    self._reset_429_handler()
                     if report_state not in [AbstractVirtReport.STATE_CANCELED,
                                             AbstractVirtReport.STATE_FAILED,
                                             AbstractVirtReport.STATE_FINISHED]:
                         self.is_first_job_check = False
                         self.next_job_status_check = time.time() + (MinimumJobPollInterval * 2)
 
-            if not self.report_in_progress and self.queued_reports and time.time() > self.send_after:
+            if not self.reports_in_progress and self.queued_reports and time.time() > self.send_after:
                 # No report is processed, send next one
                 if not self.options.print_:
                     self.send_current_report()
-
-            if self.options.oneshot and not self.oneshot_remaining and not self.report_in_progress and (not self.queued_reports or self.options.print_):
+            if self.options.oneshot and not self.oneshot_remaining and not self.reports_in_progress and (not self.queued_reports or self.options.print_):
                 break
 
         self.queue = None
