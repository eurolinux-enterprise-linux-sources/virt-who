diff --git a/rel-eng/packages/virt-who b/rel-eng/packages/virt-who
index 572c51f..ef0736b 100644
--- a/rel-eng/packages/virt-who
+++ b/rel-eng/packages/virt-who
@@ -1 +1 @@
-0.19-6 ./
+0.19-7 ./
diff --git a/tests/test_virt.py b/tests/test_virt.py
index 04b0117..4a427e4 100644
--- a/tests/test_virt.py
+++ b/tests/test_virt.py
@@ -8,6 +8,7 @@ from base import TestBase
 from mock import Mock, patch, call
 from threading import Event
 
+from virtwho import MinimumJobPollInterval
 from virtwho.config import ConfigManager, Config
 from virtwho.manager import ManagerThrottleError, ManagerFatalError
 from virtwho.virt import HostGuestAssociationReport, Hypervisor, Guest, \
@@ -279,7 +280,7 @@ class TestDestinationThread(TestBase):
             local_variables = {'count': 0}
 
             def mock_check_report_state(report):
-                if local_variables['count'] > 0:
+                if local_variables['count'] > 1:
                     report.state = AbstractVirtReport.STATE_FINISHED
                 else:
                     report.state = AbstractVirtReport.STATE_CREATED
@@ -290,7 +291,6 @@ class TestDestinationThread(TestBase):
         manager.check_report_state = Mock(side_effect=check_report_mock)
         logger = Mock()
         config = Mock()
-        config.polling_interval = 10
         terminate_event = Mock()
         interval = 10  # Arbitrary for this test
         options = Mock()
@@ -307,15 +307,13 @@ class TestDestinationThread(TestBase):
         destination_thread.wait = Mock()
         destination_thread.is_terminated = Mock(return_value=False)
         destination_thread._send_data(data_to_send)
-        # We expect there two be two calls to wait with the value of the
-        # polling_interval attr because we'd like to wait one polling
-        # interval before making the first check. Because the mock
-        # check_report_state function will modify the report to be in the
-        # successful state after the first call, we expect to wait exactly
-        # twice, both of duration config.polling_interval
+        # There should be three waits, one after the job is submitted with duration of
+        # MinimumJobPollingInterval. The second and third with duration MinimumJobPollInterval * 2
+        # (and all subsequent calls as demonstrated by the third wait)
         destination_thread.wait.assert_has_calls([
-            call(wait_time=config.polling_interval),
-        ])
+            call(wait_time=MinimumJobPollInterval),
+            call(wait_time=MinimumJobPollInterval * 2),
+            call(wait_time=MinimumJobPollInterval * 2)])
 
     def test_send_data_poll_async_429(self):
         # This test's that when a 429 is detected during async polling
@@ -339,7 +337,6 @@ class TestDestinationThread(TestBase):
         data_to_send = {'source1': report1,
                         'source2': report2}
         config = Mock()
-        config.polling_interval = 10
         error_to_throw = ManagerThrottleError(retry_after=62)
 
         manager = Mock()
@@ -360,7 +357,8 @@ class TestDestinationThread(TestBase):
                 return report
             return mock_check_report_state
         states = [error_to_throw, AbstractVirtReport.STATE_FINISHED]
-        expected_wait_calls = [call(wait_time=error_to_throw.retry_after)]
+        expected_wait_calls = [call(wait_time=MinimumJobPollInterval),
+                               call(wait_time=error_to_throw.retry_after)]
 
         check_report_mock = check_report_state_closure(states)
         manager.check_report_state = Mock(side_effect=check_report_mock)
diff --git a/virt-who.spec b/virt-who.spec
index fa5bf6a..5597d62 100644
--- a/virt-who.spec
+++ b/virt-who.spec
@@ -6,7 +6,7 @@
 
 Name:           virt-who
 Version:        0.19
-Release:        6%{?dist}
+Release:        7%{?dist}
 Summary:        Agent for reporting virtual guest IDs to subscription-manager
 
 Group:          System Environment/Base
@@ -127,6 +127,9 @@ fi
 
 
 %changelog
+* Wed Oct 25 2017 Christopher Snyder <csnyder@redhat.com> 0.19-7
+- 1506263: Updates to the job polling frequency (csnyder@redhat.com)
+
 * Fri Jul 21 2017 Christopher Snyder <csnyder@redhat.com> 0.19-6
 - 1458674: Update use of result data to match the new async api
   (csnyder@redhat.com)
diff --git a/virtwho/__init__.py b/virtwho/__init__.py
index f4a7b72..b99fe51 100644
--- a/virtwho/__init__.py
+++ b/virtwho/__init__.py
@@ -2,3 +2,4 @@
 # Default interval for sending list of UUIDs
 DefaultInterval = 3600  # One per hour
 MinimumSendInterval = 60  # One minute
+MinimumJobPollInterval = 15
diff --git a/virtwho/manager/subscriptionmanager/subscriptionmanager.py b/virtwho/manager/subscriptionmanager/subscriptionmanager.py
index 8e985b7..43c0e6e 100644
--- a/virtwho/manager/subscriptionmanager/subscriptionmanager.py
+++ b/virtwho/manager/subscriptionmanager/subscriptionmanager.py
@@ -235,6 +235,8 @@ class SubscriptionManager(Manager):
             result = self.connection.getJob(job_id)
         except BadStatusLine:
             raise ManagerError("Communication with subscription manager interrupted")
+        except rhsm_connection.RateLimitExceededException as e:
+            raise ManagerThrottleError(e.retry_after)
         except rhsm_connection.ConnectionException as e:
             if hasattr(e, 'code'):
                 raise ManagerError("Communication with subscription manager failed with code %d: %s" % (e.code, str(e)))
diff --git a/virtwho/virt/virt.py b/virtwho/virt/virt.py
index f4d63b4..3222554 100644
--- a/virtwho/virt/virt.py
+++ b/virtwho/virt/virt.py
@@ -31,7 +31,7 @@ import fnmatch
 from virtwho.config import NotSetSentinel, Satellite5DestinationInfo, \
     Satellite6DestinationInfo, DefaultDestinationInfo
 from virtwho.manager import ManagerError, ManagerThrottleError, ManagerFatalError
-from virtwho import MinimumSendInterval
+from virtwho import MinimumSendInterval, MinimumJobPollInterval
 
 try:
     from collections import OrderedDict
@@ -437,14 +437,14 @@ class IntervalThread(Thread):
         @return: The number of seconds that should be waited before retrying
         @rtype: int
         """
-        wait_time = retry_after
-        if wait_time and wait_time >= MinimumSendInterval:
-            return wait_time
-        if number_of_failures > 0:
-            wait_time = MinimumSendInterval * number_of_failures
-        else:
-            wait_time = MinimumSendInterval
-        return wait_time
+        if retry_after is not None:
+            try:
+                return int(retry_after)
+            except (TypeError, ValueError):
+                # if the retry_after value is not convertable to an int, don't use it
+                pass
+        # If there is no good retry-after value to use, use twice the polling interval
+        return MinimumJobPollInterval * 2
 
 
 class DestinationThread(IntervalThread):
@@ -484,14 +484,6 @@ class DestinationThread(IntervalThread):
                                                 terminate_event=terminate_event,
                                                 interval=interval,
                                                 oneshot=oneshot)
-        # The polling interval has not been implemented as configurable yet
-        # Until the config includes the polling_interval attribute
-        # this will end up being the interval.
-        try:
-            polling_interval = self.config.polling_interval
-        except AttributeError:
-            polling_interval = self.interval
-        self.polling_interval = polling_interval or self.interval
         # This is used when there is some reason to modify how long we wait
         # EX when we get a 429 back from the server, this value will be the
         # value of the retry_after header.
@@ -629,8 +621,9 @@ class DestinationThread(IntervalThread):
                     break
                 self.wait(wait_time=self.interval_modifier)
                 self.interval_modifier = 0
-            initial_job_check = True
+
             num_429_received = 0
+            first_attempt = True
             # Poll for async results if async (retrying where necessary)
             while result and batch_host_guest_report.state not in [
                 AbstractVirtReport.STATE_CANCELED,
@@ -639,10 +632,13 @@ class DestinationThread(IntervalThread):
                 if self.interval_modifier != 0:
                     wait_time = self.interval_modifier
                     self.interval_modifier = 0
+                elif not first_attempt:
+                    wait_time = MinimumJobPollInterval * 2
                 else:
-                    wait_time = self.polling_interval
-                if not initial_job_check:
-                    self.wait(wait_time=wait_time)
+                    wait_time = MinimumJobPollInterval
+
+                self.wait(wait_time=wait_time)
+
                 try:
                     self.dest.check_report_state(batch_host_guest_report)
                 except ManagerThrottleError as e:
@@ -660,7 +656,8 @@ class DestinationThread(IntervalThread):
                     if self._oneshot:
                         sources_sent.extend(reports_batched)
                     break
-                initial_job_check = False
+                # If we get here and have to try again, it's not our first rodeo...
+                first_attempt = False
 
             # If the batch report did not reach the finished state
             # we do not want to update which report we last sent (as we
