diff --git a/rel-eng/packages/virt-who b/rel-eng/packages/virt-who
index ef0736b..9cda1b3 100644
--- a/rel-eng/packages/virt-who
+++ b/rel-eng/packages/virt-who
@@ -1 +1 @@
-0.19-7 ./
+0.19-8 ./
diff --git a/tests/test_vdsm.py b/tests/test_vdsm.py
index 0a3d7fc..6a164d5 100644
--- a/tests/test_vdsm.py
+++ b/tests/test_vdsm.py
@@ -18,27 +18,42 @@ along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 """
 
-from mock import MagicMock
+from mock import MagicMock, patch
+from unittest import TestCase
 
 from base import TestBase
 
 from virtwho.config import Config
 from virtwho.virt.vdsm import Vdsm
+from virtwho.virt.vdsm.jsonrpc import JsonRpcClient
+from virtwho.virt.vdsm.stomp import StompFrame, StompClient
+from virtwho.virt.virt import Guest
 
 
 class TestVdsm(TestBase):
     def setUp(self):
         config = Config('test', 'vdsm')
-
-        def fakeSecureConnect(self):
-            return MagicMock()
-        Vdsm._secureConnect = fakeSecureConnect
+        Vdsm._create_ssl_context = MagicMock()
         self.vdsm = Vdsm(self.logger, config, None)
-        self.vdsm.prepare()
+        self.mock_jsonrpc_client = MagicMock()
+        mock_jsonrpc_client_factory = MagicMock(return_value=self.mock_jsonrpc_client)
+
+        self.patch_jsonrpc_client = patch('virtwho.virt.vdsm.vdsm.JsonRpcClient', mock_jsonrpc_client_factory)
+        self.patch_xmlrpclib = patch('virtwho.virt.vdsm.vdsm.xmlrpclib', MagicMock())
+        self.patch_jsonrpc_client.start()
+        self.patch_xmlrpclib.start()
+
+    def tearDown(self):
+        self.patch_jsonrpc_client.stop()
+        self.patch_xmlrpclib.stop()
 
-    def test_connect(self):
-        self.vdsm.server.list = MagicMock()
-        self.vdsm.server.list.return_value = {
+    def test_connect_via_xmlrpc(self):
+        self.mock_jsonrpc_client.connect = MagicMock(side_effect=IOError)
+        self.vdsm.prepare()
+        self.assertIsNone(self.vdsm.jsonrpc_client)
+        self.assertIsNotNone(self.vdsm.xmlrpc_client)
+        self.vdsm.xmlrpc_client.list = MagicMock()
+        self.vdsm.xmlrpc_client.list.return_value = {
             'status': {
                 'code': 0
             },
@@ -56,5 +71,184 @@ class TestVdsm(TestBase):
             ]
         }
         domains = self.vdsm.listDomains()
+        self.assertIsNone(self.vdsm.jsonrpc_client)
+        self.assertEquals([d.uuid for d in domains], ['1', '2', '3'])
+        self.assertEquals([d.state for d in domains], [Guest.STATE_SHUTOFF, Guest.STATE_RUNNING, Guest.STATE_RUNNING])
+        self.assertEqual([d.virtWhoType for d in domains], ['vdsm', 'vdsm', 'vdsm'])
+        self.vdsm.xmlrpc_client.list.assert_called_once_with(True)
+
+    def test_connect_via_jsonrpc(self):
+        self.mock_jsonrpc_client.connect = MagicMock()
+        self.vdsm.prepare()
+        self.assertIsNotNone(self.vdsm.jsonrpc_client)
+        self.assertIsNone(self.vdsm.xmlrpc_client)
+        self.vdsm.jsonrpc_client.call = MagicMock()
+        self.vdsm.jsonrpc_client.call.return_value = [
+            {
+                'vmId': '1',
+                'status': 'Down'
+            }, {
+                'vmId': '2',
+                'status': 'Up'
+            }, {
+                'vmId': '3',
+                'status': 'Up'
+            }
+        ]
+        domains = self.vdsm.listDomains()
+        self.assertIsNone(self.vdsm.xmlrpc_client)
         self.assertEquals([d.uuid for d in domains], ['1', '2', '3'])
-        self.vdsm.server.list.assert_called_once_with(True)
+        self.assertEquals([d.state for d in domains], [Guest.STATE_SHUTOFF, Guest.STATE_RUNNING, Guest.STATE_RUNNING])
+        self.assertEqual([d.virtWhoType for d in domains], ['vdsm', 'vdsm', 'vdsm'])
+        self.vdsm.jsonrpc_client.call.assert_called_once_with('Host.getVMList', onlyUUID=False)
+
+
+class TestStomp(TestCase):
+    def test_stomp_message_encoding_with_headers_without_body(self):
+        connect_message = StompFrame(u'CONNECT', headers={
+           u'accept-version': u'1.2',
+           u'host': u'localhost',
+        })
+        result = connect_message.to_bytes()
+        self.assertEqual(b'CONNECT\naccept-version:1.2\nhost:localhost\n\n\x00', result)
+
+    def test_stomp_message_encoding_with_headers_with_body(self):
+        connect_message = StompFrame(u'CONNECT', headers={
+           u'accept-version': u'1.2',
+           u'host': u'localhost',
+        }, body=b'extra')
+        result = connect_message.to_bytes()
+        self.assertEqual(b'CONNECT\naccept-version:1.2\nhost:localhost\n\nextra\x00', result)
+
+    def test_stomp_message_encoding_without_headers_without_body(self):
+        connect_message = StompFrame(u'CONNECT')
+        result = connect_message.to_bytes()
+        self.assertEqual(b'CONNECT\n\n\x00', result)
+
+    def test_stomp_message_encoding_without_headers_with_body(self):
+        connect_message = StompFrame(u'CONNECT', body=b'test')
+        result = connect_message.to_bytes()
+        self.assertEqual(b'CONNECT\n\ntest\x00', result)
+
+    def test_stomp_message_decoding_without_body(self):
+        data = b'CONNECT\naccept-version:1.2\nhost:localhost\n\n\x00'
+        connect_message = StompFrame.from_bytes(data)
+        self.assertEqual(u'CONNECT', connect_message.command)
+        self.assertEqual({
+           u'accept-version': u'1.2',
+           u'host': u'localhost',
+        }, connect_message.headers)
+        self.assertEqual(connect_message.body, b'')
+
+    def test_stomp_message_decoding_with_headers_with_body(self):
+        data = b'CONNECT\naccept-version:1.2\n\nlalala\x00'
+        connect_message = StompFrame.from_bytes(data)
+        self.assertEqual(u'CONNECT', connect_message.command)
+        self.assertEqual({
+            u'accept-version': u'1.2',
+        }, connect_message.headers)
+        self.assertEqual(connect_message.body, b'lalala')
+
+    def test_stomp_message_decoding_without_headers_with_body(self):
+        data = b'CONNECT\n\nlalala\x00'
+        connect_message = StompFrame.from_bytes(data)
+        self.assertEqual(u'CONNECT', connect_message.command)
+        self.assertEqual({}, connect_message.headers)
+        self.assertEqual(connect_message.body, b'lalala')
+
+    def test_stomp_message_decoding_without_headers_without_body(self):
+        data = b'CONNECT\n\n\x00'
+        connect_message = StompFrame.from_bytes(data)
+        self.assertEqual(u'CONNECT', connect_message.command)
+        self.assertEqual({}, connect_message.headers)
+        self.assertEqual(connect_message.body, b'')
+
+
+class StompClientTest(TestCase):
+    def test_stomp_client_connect_sends_connect_frame(self):
+        with patch('socket.socket') as socket_factory:
+            mock_socket = MagicMock()
+            socket_factory.return_value = mock_socket
+            mock_socket.recv.return_value = b'CONNECTED\n\n\x00'
+            client = StompClient('localhost', 54321)
+            client.connect()
+        mock_socket.sendall.assert_called_once_with(b'CONNECT\naccept-version:1.2\nhost:localhost\n\n\x00')
+
+    def test_stomp_client_cleans_up_subscriptions_on_close(self):
+        with patch('socket.socket') as socket_factory:
+            with patch('uuid.uuid4') as mock_uuid:
+                mock_uuid.return_value = '42'
+                mock_socket = MagicMock()
+                socket_factory.return_value = mock_socket
+                mock_socket.recv.return_value = b'CONNECTED\n\n\x00'
+                client = StompClient('localhost', 54321)
+                client.connect()
+                client.subscribe('bob')
+                client.close()
+        mock_socket.sendall.assert_called_with(b'UNSUBSCRIBE\nid:42\n\n\x00')
+
+
+class JsonRpcTest(TestCase):
+    def test_jsonrpc_client_subscribes_to_response_queue(self):
+        with patch('virtwho.virt.vdsm.jsonrpc.StompClient') as mock_client_factory:
+            mock_stomp_client = MagicMock()
+            mock_client_factory.return_value = mock_stomp_client
+            jsonrpc_client = JsonRpcClient('localhost', '54321')
+            jsonrpc_client.connect()
+            mock_stomp_client.subscribe.assert_called_once_with(jsonrpc_client.id)
+
+    def test_jsonrpc_client_payload_encoding_with_params(self):
+        with patch('virtwho.virt.vdsm.jsonrpc.StompClient') as mock_client_factory:
+            with patch('uuid.uuid4') as mock_uuid:
+                mock_uuid.return_value = 42
+                mock_stomp_client = MagicMock()
+                mock_client_factory.return_value = mock_stomp_client
+                mock_stomp_client.receive.return_value = StompFrame('MESSAGE', body=b'{"result":"bar"}')
+                jsonrpc_client = JsonRpcClient('localhost', '54321')
+                jsonrpc_client.connect()
+                result = jsonrpc_client.call('test', foo='bar')
+                self.assertEquals(result, u'bar')
+                mock_stomp_client.send.assert_called_with(u'SEND', {
+                    u'content-length': 74,
+                    u'destination': u'jms.topic.vdsm_requests',
+                    u'reply-to': u'42'
+                }, b'{"params": {"foo": "bar"}, "jsonrpc": "2.0", "method": "test", "id": "42"}')
+
+    def test_jsonrpc_client_payload_encoding_without_params(self):
+        with patch('virtwho.virt.vdsm.jsonrpc.StompClient') as mock_client_factory:
+            with patch('uuid.uuid4') as mock_uuid:
+                mock_uuid.return_value = 42
+                mock_stomp_client = MagicMock()
+                mock_client_factory.return_value = mock_stomp_client
+                mock_stomp_client.receive.return_value = StompFrame('MESSAGE', body=b'{"result":"bar"}')
+                jsonrpc_client = JsonRpcClient('localhost', '54321')
+                jsonrpc_client.connect()
+                result = jsonrpc_client.call('test')
+                self.assertEqual(result, u'bar')
+                mock_stomp_client.send.assert_called_with(u'SEND', {
+                    u'content-length': 48,
+                    u'destination': u'jms.topic.vdsm_requests',
+                    u'reply-to': u'42'
+                }, b'{"jsonrpc": "2.0", "method": "test", "id": "42"}')
+
+    def test_jsonrpc_client_errs_on_error_frame(self):
+        with patch('virtwho.virt.vdsm.jsonrpc.StompClient') as mock_client_factory:
+            with patch('uuid.uuid4') as mock_uuid:
+                mock_uuid.return_value = 42
+                mock_stomp_client = MagicMock()
+                mock_client_factory.return_value = mock_stomp_client
+                mock_stomp_client.receive.return_value = StompFrame('ERROR', body=b'uh-oh!')
+                jsonrpc_client = JsonRpcClient('localhost', '54321')
+                jsonrpc_client.connect()
+                self.assertRaises(RuntimeError, jsonrpc_client.call, 'test')
+
+    def test_jsonrpc_client_errs_on_error_json(self):
+        with patch('virtwho.virt.vdsm.jsonrpc.StompClient') as mock_client_factory:
+            with patch('uuid.uuid4') as mock_uuid:
+                mock_uuid.return_value = 42
+                mock_stomp_client = MagicMock()
+                mock_client_factory.return_value = mock_stomp_client
+                mock_stomp_client.receive.return_value = StompFrame('MESSAGE', body=b'{"error":{"message":"foo"}}')
+                jsonrpc_client = JsonRpcClient('localhost', '54321')
+                jsonrpc_client.connect()
+                self.assertRaises(RuntimeError, jsonrpc_client.call, 'test')
diff --git a/virt-who.spec b/virt-who.spec
index 5597d62..bf6c99d 100644
--- a/virt-who.spec
+++ b/virt-who.spec
@@ -6,7 +6,7 @@
 
 Name:           virt-who
 Version:        0.19
-Release:        7%{?dist}
+Release:        8%{?dist}
 Summary:        Agent for reporting virtual guest IDs to subscription-manager
 
 Group:          System Environment/Base
@@ -27,6 +27,7 @@ Requires:       python-suds
 # m2crypto is required for Hyper-V support
 Requires:       m2crypto
 Requires:       python-requests
+Requires:       openssl
 
 %if %{use_systemd}
 Requires: systemd-python
@@ -127,6 +128,9 @@ fi
 
 
 %changelog
+* Mon Feb 05 2018 Kevin Howell <khowell@redhat.com> 0.19-8
+- 1540296: Add JSON-RPC support for VDSM (khowell@redhat.com)
+
 * Wed Oct 25 2017 Christopher Snyder <csnyder@redhat.com> 0.19-7
 - 1506263: Updates to the job polling frequency (csnyder@redhat.com)
 
diff --git a/virtwho/virt/vdsm/jsonrpc.py b/virtwho/virt/vdsm/jsonrpc.py
new file mode 100644
index 0000000..4200065
--- /dev/null
+++ b/virtwho/virt/vdsm/jsonrpc.py
@@ -0,0 +1,149 @@
+# Module for JSON-RPC over STOMP, part of virt-who
+#
+# Copyright (C) 2018 Kevin Howell <khowell@redhat.com>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+"""
+Minimal implementation of the JSON-RPC specification (http://www.jsonrpc.org/specification) over STOMP to enable a
+client for VDSM.
+
+There are better developed JSON-RPC libraries for Python available (such as jsonrpclib), but for RHEL/CentOS, at the
+time of writing, only available in EPEL.
+"""
+
+from __future__ import unicode_literals
+
+import json
+import ssl
+import uuid
+
+from virtwho.virt.vdsm.stomp import StompClient
+
+
+class JsonRpcClient(object):
+    """JSON-RPC 2.0 over STOMP client"""
+
+    def __init__(self, host, port, ssl_context=None, timeout=None):
+        """Create a JSON-RPC over STOMP client.
+
+        :param host: STOMP server hostname.
+        :param port: STOMP server port.
+        :param ssl_context: SSL context if using TLS or None.
+        :param timeout: timeout for blocking operations.
+        """
+        self.id = unicode(uuid.uuid4())
+        self.stomp = StompClient(host, port, ssl_context=ssl_context, timeout=timeout)
+
+    def connect(self):
+        """Connect to the STOMP server."""
+        self.stomp.connect()
+        self.stomp.subscribe(self.id)
+
+    def close(self):
+        """Close the underlying connection."""
+        self.stomp.close()
+
+    def __enter__(self):
+        self.connect()
+        return self
+
+    def __exit__(self, *args, **kwargs):
+        self.close()
+
+    def call(self, method, **params):
+        """Call a method via JSON-RPC.
+
+        :param method: name of method.
+        :param params: parameters for the method.
+        :return: the result as a dict if successful.
+        :raises: RuntimeError if the result is an error or cannot be decoded.
+        """
+        data_object = {
+            'jsonrpc': '2.0',
+            'method': method,
+            'id': unicode(uuid.uuid4())
+        }
+        if params:
+            data_object['params'] = {}
+            for key, value in params.items():
+                data_object['params'][key] = value
+        data = json.dumps(data_object).encode('utf-8')
+        self.stomp.send('SEND', {
+            'destination': 'jms.topic.vdsm_requests',
+            'content-length': len(data),
+            'reply-to': self.id,
+        }, data)
+        response = self.stomp.receive()
+        if response.command == 'ERROR':
+            raise RuntimeError(response.body.decode('utf-8'))
+        response_json = json.loads(response.body.decode('utf-8'))
+        if 'error' in response_json:
+            # TODO log verbose error object?
+            raise RuntimeError(response_json['error']['message'])
+        return response_json['result']
+
+
+def main():
+    """Utility for one-off calls to VDSM via JSON-RPC over STOMP.
+
+    Example invocation:
+
+    python -m virtwho.virt.vdsm.jsonrpc
+        --cert /etc/pki/vdsm/certs/vdsmcert.pem
+        --key /etc/pki/vdsm/keys/vdsmkey.pem
+        $HOSTNAME 54321
+        Host.getVMList onlyUUID=False
+    """
+    import argparse
+
+    parser = argparse.ArgumentParser(description='vdsm over jsonrpc utility')
+
+    parser.add_argument('--key', help='path to key pem file')
+    parser.add_argument('--cert', help='path to cert pem file')
+    parser.add_argument('host', help='hostname')
+    parser.add_argument('port', help='port')
+    parser.add_argument('method', help='method to call via JSON-RPC')
+    parser.add_argument('args', help='arguments for the call with format $key=$value', nargs='*')
+    args = parser.parse_args()
+
+    ssl_enabled = 'cert' in args and 'key' in args
+    if ('key' in args or 'cert' in args) and not ssl_enabled:
+        raise ValueError('Must provide both --cert and --key for SSL')
+
+    ssl_context = None
+    if ssl_enabled:
+        ssl_context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
+        ssl_context.verify_mode = ssl.CERT_NONE
+        ssl_context.load_cert_chain(args.cert, args.key)
+
+    # parse method args
+    method_args = {}
+    for arg in args.args:
+        key, value = arg.split('=')
+        key = key.strip()
+        value = value.strip()
+        if value.lower() == 'true':
+            value = True
+        if value.lower() == 'false':
+            value = False
+        method_args[key] = value
+
+    with JsonRpcClient(args.host, args.port, ssl_context=ssl_context) as jsonrpc_client:
+        print(json.dumps(jsonrpc_client.call(args.method, **method_args), indent=True))
+
+
+if __name__ == '__main__':
+    main()
diff --git a/virtwho/virt/vdsm/stomp.py b/virtwho/virt/vdsm/stomp.py
new file mode 100644
index 0000000..aea914d
--- /dev/null
+++ b/virtwho/virt/vdsm/stomp.py
@@ -0,0 +1,246 @@
+# Module for STOMP messaging, part of virt-who
+#
+# Copyright (C) 2018 Kevin Howell <khowell@redhat.com>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+"""
+Implements enough of the STOMP specification (https://stomp.github.io/stomp-specification-1.2.html) to enable
+implementation of a client for VDSM's JSON-RPC API over STOMP. Could be easily improved to be a general STOMP client;
+TODOs and FIXMEs document known gaps.
+
+There are better developed STOMP libraries for Python available (such as stomper), but for RHEL/CentOS, at the time of
+writing, only available in EPEL.
+"""
+
+from __future__ import unicode_literals
+
+import logging
+import socket
+import uuid
+
+log = logging.getLogger(__name__)
+
+
+class StompFrame(object):
+    """STOMP frame as described in the STOMP specification."""
+
+    def __init__(self, command, headers=None, body=None):
+        """Create a new StompFrame.
+
+        :param command: STOMP command as a string (ex. 'CONNECT').
+        :param headers: dict containing STOMP headers.
+        :param body: body as bytes.
+        """
+        self.command = command
+        self.headers = headers or {}
+        self.body = body or b''
+
+    @classmethod
+    def from_bytes(cls, data):
+        """Decode bytes into a StompFrame.
+
+        :param data: a single STOMP frame as bytes.
+        :return: a StompFrame.
+        :raises:
+        """
+        parts = [part for part in data.splitlines()]
+        if not parts:
+            raise IOError('Cannot parse data as STOMP frame')
+
+        # find indexOf empty line, this is the indicator what follows is body
+        try:
+            end_of_headers_index = parts.index(b'')
+        except ValueError:
+            raise IOError('Cannot parse data as STOMP frame')
+
+        command_part = parts[0]
+        header_parts = parts[1:end_of_headers_index]
+        body_parts = parts[end_of_headers_index:]  # TODO assert that remaining data ends in EOF (NULL)
+
+        return StompFrame(
+            command=command_part.decode('utf-8'),
+            headers=cls._decode_headers(header_parts),
+            body=cls._unescape_bytes(b''.join(body_parts)[:-1]),  # TODO handle content-length
+        )
+
+    def to_bytes(self):
+        """Encode the STOMP frame as bytes.
+
+        :return: bytes.
+        """
+        frame_without_body = '{command}\n{headers}\n'.format(
+            command=self.command,
+            headers=self._encode_headers(),
+        ).encode('utf-8')
+        return frame_without_body + (self.body) + b'\x00'
+
+    def _encode_headers(self):
+        if not self.headers:
+            return b''
+        return b'\n'.join(
+            [b':'.join(
+                [
+                    self._escape_bytes(key.encode('utf-8')),
+                    self._escape_bytes(unicode(value).encode('utf-8')),
+                ]
+            ) for key, value in sorted(self.headers.items())]  # sort the headers for predictable messages
+        ) + '\n'
+
+    @classmethod
+    def _decode_headers(cls, data):
+        headers = {}
+        for line in data:
+            key, value = line.split(b':')  # TODO err intelligently if more than one ':' detected
+            key = cls._unescape_bytes(key).decode('utf-8')
+            value = cls._unescape_bytes(value).decode('utf-8')
+            if key not in headers:  # first value wins
+                headers[key] = value
+        return headers
+
+    @staticmethod
+    def _escape_bytes(data):
+        if data is None:
+            return b''
+        data = data.replace(b'\\', b'\\\\')  # \ -> \\
+        data = data.replace(b'\r', b'\\r')   # CR -> \r
+        data = data.replace(b'\n', b'\\n')   # LF -> \n
+        data = data.replace(b':', b'\\c')    # : -> \c
+        return data
+
+    @staticmethod
+    def _unescape_bytes(data):
+        data = data.replace(b'\\c', b':')    # \c -> :
+        data = data.replace(b'\\n', b'\n')   # \n -> LF
+        data = data.replace(b'\\r', b'\r')   # \r -> CR
+        # TODO could check here that there are illegal escape sequences (ex. \t), see STOMP spec for details
+        data = data.replace(b'\\\\', b'\\')  # \\ -> \
+        return data
+
+
+class StompClient(object):
+    """Minimal STOMP client with SSL support."""
+
+    def __init__(self, host, port, ssl_context=None, timeout=None):
+        """Create a new STOMP client.
+
+        :param host: STOMP server hostname.
+        :param port: STOMP server port.
+        :param ssl_context: SSL context if using TLS.
+        :param timeout: timeout for blocking operations.
+        """
+        self.host = host
+        self.port = port
+        self.ssl_context = ssl_context
+        self.timeout = timeout
+        self.socket = None
+        self.buffer = b''  # FIXME for performance, could construct a buffer and then recv_into instead...
+        self.subscription_ids = []
+
+    def __enter__(self):
+        self.connect()
+        return self
+
+    def __exit__(self, *args, **kwargs):
+        self.close()
+
+    def connect(self):
+        """Connect to the STOMP server.
+
+        Sends a STOMP CONNECT and consumes the subsequent CONNECTED message.
+
+        :raises: IOError if no connection attempts succeed.
+        """
+        for family, _, _, _, addr in socket.getaddrinfo(self.host, self.port):
+            try:
+                self.socket = socket.socket(family)
+                self.socket.settimeout(self.timeout)
+                if self.ssl_context:
+                    if hasattr(self.ssl_context, 'wrap_socket'):
+                        self.socket = self.ssl_context.wrap_socket(self.socket)
+                    else:
+                        import M2Crypto.SSL.Connection
+                        self.socket = M2Crypto.SSL.Connection(self.ssl_context)
+                self.socket.connect(addr)
+                message = StompFrame('CONNECT', headers={
+                    'accept-version': '1.2',
+                    'host': self.host,
+                })
+                self.socket.sendall(message.to_bytes())
+                self._validate_connected(self._recv_frame())
+                return  # success connecting
+            except (socket.error, IOError) as e:
+                log.warning('Unable to connect %s:%s: %s' % (self.host, self.port, unicode(e)))
+        raise IOError('Unable to connect to %s:%s' % (self.host, self.port))
+
+    @staticmethod
+    def _validate_connected(data):
+        frame = StompFrame.from_bytes(data)
+        if frame.command != 'CONNECTED':
+            raise IOError('Did not parse expected CONNECTED frame')
+
+    def close(self):
+        """Close STOMP server connection, unsubscribing from any tracked subscriptions."""
+        for subscription_id in self.subscription_ids:
+            self.unsubscribe(subscription_id)
+        self.socket.close()
+        self.socket = None
+
+    def send(self, command, headers=None, data=None):
+        """Construct and send a STOMP frame.
+
+        :param command: STOMP command as a string.
+        :param headers: dict containing STOMP headers.
+        :param data: STOMP body as bytes.
+        """
+        self.socket.sendall(StompFrame(command, headers, data).to_bytes())
+
+    def receive(self):
+        """Receive a STOMP frame.
+
+        :return: a StompFrame.
+        """
+        return StompFrame.from_bytes(self._recv_frame())
+
+    def _recv_frame(self):
+        while b'\x00' not in self.buffer:
+            self.buffer += self.socket.recv(4096)
+        frame, self.buffer = self.buffer.split(b'\x00', 1)
+        # add null byte back to frame
+        frame += b'\x00'
+        return frame
+
+    def subscribe(self, destination):
+        """Subscribe to a queue or topic.
+
+        :param destination: Name of the queue or topic to subscribe to.
+        :return: randomly generated subscription ID.
+        """
+        subscription_id = uuid.uuid4()
+        self.send('SUBSCRIBE', {
+            'id': subscription_id,
+            'destination': destination,
+        })
+        self.subscription_ids.append(subscription_id)
+        return subscription_id
+
+    def unsubscribe(self, subscription_id):
+        """Unsubscribe from a given subscription ID.
+
+        :param subscription_id: id returned by subscribe call.
+        """
+        self.send('UNSUBSCRIBE', {
+            'id': subscription_id,
+        })
diff --git a/virtwho/virt/vdsm/vdsm.py b/virtwho/virt/vdsm/vdsm.py
index 838241e..35f3fb6 100644
--- a/virtwho/virt/vdsm/vdsm.py
+++ b/virtwho/virt/vdsm/vdsm.py
@@ -2,7 +2,7 @@
 Module for accessing vdsm, part of virt-who
 
 Parts of this file is based on rhn-virtualization from spacewalk
-http://git.fedorahosted.org/git/?p=spacewalk.git;a=tree;f=client/tools/rhn-virtualization
+https://github.com/spacewalkproject/spacewalk/tree/master/client/tools/rhn-virtualization
 
 Copyright (C) 2011 Radek Novacek <rnovacek@redhat.com>
 
@@ -24,9 +24,11 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 import re
 import xmlrpclib
 from ConfigParser import SafeConfigParser, NoSectionError, NoOptionError
+import ssl
 import subprocess
 
 from virtwho.virt import Virt, Guest
+from virtwho.virt.vdsm.jsonrpc import JsonRpcClient
 
 
 class VdsmError(Exception):
@@ -47,8 +49,13 @@ VDSM_STATE_TO_GUEST_STATE = {
     'Powering up': Guest.STATE_SHUTOFF
 }
 
+VDSM_JSONRPC_TIMEOUT = 300  # 5 minutes, borrowed from esx MAX_WAIT_TIME
+
 
 class Vdsm(Virt):
+    """
+    Class for interacting with vdsmd daemon.
+    """
     CONFIG_TYPE = "vdsm"
 
     def __init__(self, logger, config, dest, terminate_event=None,
@@ -57,14 +64,16 @@ class Vdsm(Virt):
                                    terminate_event=terminate_event,
                                    interval=interval,
                                    oneshot=oneshot)
-        self._readConfig("/etc/vdsm/vdsm.conf")
+        self._read_config("/etc/vdsm/vdsm.conf")
+        self.xmlrpc_client = None
+        self.jsonrpc_client = None
 
     def isHypervisor(self):
         return False
 
-    def _readConfig(self, configName):
+    def _read_config(self, config_name):
         parser = SafeConfigParser()
-        parser.read(configName)
+        parser.read(config_name)
         try:
             self.ssl = parser.get("vars", "ssl").lower() in ["1", "true"]
         except (NoSectionError, NoOptionError):
@@ -82,53 +91,127 @@ class Vdsm(Virt):
         except (NoSectionError, NoOptionError):
             self.management_port = '54321'
 
-    def _getLocalVdsName(self, tsPath):
+    def _get_local_vds_name(self, trusted_store_path):
         p = subprocess.Popen([
             '/usr/bin/openssl', 'x509', '-noout', '-subject', '-in',
-            '%s/certs/vdsmcert.pem' % tsPath], stdout=subprocess.PIPE, close_fds=True)
+            '%s/certs/vdsmcert.pem' % trusted_store_path], stdout=subprocess.PIPE, close_fds=True)
         out, err = p.communicate()
         if p.returncode != 0:
             return '0'
-        return re.search('/CN=([^/$\n]+)', out).group(1)
-
-    def _secureConnect(self):
-        addr = self._getLocalVdsName(self.trust_store_path)
+        return re.search('CN *= *([^,/$\n]+)', out).group(1)
 
-        from M2Crypto.m2xmlrpclib import SSL_Transport
-        from M2Crypto import SSL
+    def _get_addr(self):
+        return self._get_local_vds_name(self.trust_store_path)
 
-        KEYFILE = self.trust_store_path + '/keys/vdsmkey.pem'
-        CERTFILE = self.trust_store_path + '/certs/vdsmcert.pem'
-        CACERT = self.trust_store_path + '/certs/cacert.pem'
+    @staticmethod
+    def _need_m2crypto():
+        """Determine whether M2Crypto usage is necessary.
 
-        ctx = SSL.Context()
+        If the python version supports SSL contexts and allows specifying them in xmlrpc clients, we do not need
+        M2Crypto.
+        """
+        if not hasattr(ssl, 'create_default_context'):
+            return False
+        try:
+            xmlrpclib.ServerProxy('https://localhost', context=ssl.create_default_context())
+            return True
+        except TypeError:
+            return False
+
+    def _create_ssl_context(self):
+        key_file = self.trust_store_path + '/keys/vdsmkey.pem'
+        cert_file = self.trust_store_path + '/certs/vdsmcert.pem'
+        ca_cert = self.trust_store_path + '/certs/cacert.pem'
+
+        if self._need_m2crypto():
+            ctx = ssl.create_default_context(capath=ca_cert)
+            ctx.load_cert_chain(cert_file, key_file)
+            ctx.check_hostname = False
+            ctx.verify_mode = ssl.CERT_NONE
+        else:
+            from M2Crypto import SSL
 
-        ctx.set_verify(SSL.verify_peer | SSL.verify_fail_if_no_peer_cert, 16)
-        ctx.load_verify_locations(CACERT)
-        ctx.load_cert(CERTFILE, KEYFILE)
+            ctx = SSL.Context()
 
-        return xmlrpclib.Server('https://%s:%s' % (addr, self.management_port), SSL_Transport(ctx))
+            ctx.set_verify(SSL.verify_peer | SSL.verify_fail_if_no_peer_cert, 16)
+            ctx.load_verify_locations(ca_cert)
+            ctx.load_cert(cert_file, key_file)
+        return ctx
 
     def connect(self):
         if self.trust_store_path:
-            try:
-                self.server = self._secureConnect()
+            ssl_context = self._create_ssl_context()
+            addr = self._get_local_vds_name(self.trust_store_path)
+            client = self._jsonrpc(addr, ssl_context) or self._xmlrpc(addr, ssl_context)
+            if client:
                 return
-            except Exception as e:
-                self.logger.exception(e)
-        # Try http version if ssl is off or fails
-        self.server = xmlrpclib.Server("http://localhost:%s" % self.management_port)
+
+        # Try http versions if ssl is off or fails
+        self._jsonrpc('localhost') or self._xmlrpc('localhost')
+
+    def _jsonrpc(self, addr, ssl_context=None):
+        try:
+            jsonrpc_client = JsonRpcClient(addr, self.management_port, ssl_context, timeout=VDSM_JSONRPC_TIMEOUT)
+            jsonrpc_client.connect()
+            self.jsonrpc_client = jsonrpc_client
+            return True
+        except IOError:
+            if ssl_context:
+                description = 'JSON-RPC with SSL'
+            else:
+                description = 'JSON-RPC'
+            self.logger.warning('Unable to connect via %s' % description, exc_info=True)
+        return False
+
+    def _xmlrpc(self, addr, ssl_context=None):
+        try:
+            transport = None
+            if ssl_context:
+                if self._need_m2crypto():
+                    transport = xmlrpclib.SafeTransport(context=ssl_context)
+                else:
+                    from M2Crypto.m2xmlrpclib import SSL_Transport
+                    transport = SSL_Transport(ssl_context)
+                uri = 'https://%s:%s' % (addr, self.management_port)
+            else:
+                uri = 'http://%s:%s' % (addr, self.management_port)
+            xmlrpc_client = xmlrpclib.ServerProxy(uri, transport)
+            xmlrpc_client.system.listMethods()
+            self.xmlrpc_client = xmlrpc_client
+            return True
+        except Exception:  # NOTE: unfortunately there are many ways to fail, so the exception clause is broad
+            if ssl_context:
+                description = 'XML-RPC with SSL'
+            else:
+                description = 'XML-RPC'
+            self.logger.warning('Unable to connect via %s' % description, exc_info=True)
+        return False
 
     def prepare(self):
         self.connect()
 
-    def listDomains(self):
-        domains = []
-        response = self.server.list(True)
+    def _get_vm_list_xmlrpc(self):
+        response = self.xmlrpc_client.list(True)
         if response['status']['code'] != 0:
             self.logger.error("Unable to list virtual machines: %s", response['status']['message'])
         else:
-            for vm in response['vmList']:
+            return response['vmList']
+
+    def _get_vm_list_jsonrpc(self):
+        try:
+            return self.jsonrpc_client.call('Host.getVMList', onlyUUID=False)
+        except (IOError, RuntimeError):
+            self.logger.exception("Unable to list virtual machines")
+
+    def listDomains(self):
+        domains = []
+        vm_list = None
+        if self.jsonrpc_client is not None:
+            vm_list = self._get_vm_list_jsonrpc()
+        elif self.xmlrpc_client is not None:
+            vm_list = self._get_vm_list_xmlrpc()
+        if vm_list:
+            for vm in vm_list:
                 status = VDSM_STATE_TO_GUEST_STATE.get(vm['status'], Guest.STATE_UNKNOWN)
                 domains.append(Guest(vm['vmId'], self, status))
         return domains
