commit d266d7ae1cace50189c126fc13440bbb820ed086
Author: Radek Novacek <rnovacek@redhat.com>
Date:   Tue Jan 26 15:29:45 2016 +0100

    Refactor main loop and job scheduling
    
    The main loop was really chaotic and there were problems with job
    scheduling. Now it works in more obvious way.

diff --git a/log.py b/log.py
index eca8616..77851d6 100644
--- a/log.py
+++ b/log.py
@@ -263,6 +263,10 @@ class Logger(object):
             cls._queue_logger.start_logging()
         return cls._queue_logger
 
+    @classmethod
+    def has_queue_logger(cls):
+        return cls._queue_logger is not None
+
 
 def init(options):
     return Logger.initialize(options)
@@ -289,6 +293,10 @@ def getQueueLogger():
     return Logger.get_queue_logger()
 
 
+def hasQueueLogger():
+    return Logger.has_queue_logger()
+
+
 def closeLogger(logger):
     while len(logger.handlers):
         h = logger.handlers[0]
diff --git a/manager/__init__.py b/manager/__init__.py
index e15c802..836a5b9 100644
--- a/manager/__init__.py
+++ b/manager/__init__.py
@@ -1,4 +1,4 @@
 
-from manager import Manager, ManagerError, ManagerFatalError
+from manager import Manager, ManagerError, ManagerFatalError, ManagerThrottleError
 
-__all__ = ['Manager', 'ManagerError', 'ManagerFatalError']
+__all__ = ['Manager', 'ManagerError', 'ManagerFatalError', 'ManagerThrottleError']
diff --git a/manager/manager.py b/manager/manager.py
index d7308b0..d71c0a7 100644
--- a/manager/manager.py
+++ b/manager/manager.py
@@ -27,12 +27,27 @@ class ManagerFatalError(Exception):
     pass
 
 
+class ManagerThrottleError(Exception):
+    '''
+    Exception that is thrown when manager is too busy and want us to
+    send reports less often.
+    '''
+    def __init__(self, retry_after=None):
+        self.retry_after = retry_after
+
+
 class Manager(object):
     def sendVirtGuests(self, report, options=None):
         raise NotImplementedError()
 
     def hypervisorCheckIn(self, report, options=None):
         raise NotImplementedError()
+
+    def check_report_state(self, report):
+        '''
+        Check state of given report. This is used to check server side
+        job if finished.
+        '''
         raise NotImplementedError()
 
     @classmethod
diff --git a/manager/subscriptionmanager/subscriptionmanager.py b/manager/subscriptionmanager/subscriptionmanager.py
index 6685ae7..5eadf2e 100644
--- a/manager/subscriptionmanager/subscriptionmanager.py
+++ b/manager/subscriptionmanager/subscriptionmanager.py
@@ -26,7 +26,8 @@ import rhsm.connection as rhsm_connection
 import rhsm.certificate as rhsm_certificate
 import rhsm.config as rhsm_config
 
-from ..manager import Manager, ManagerError, ManagerFatalError
+from ..manager import Manager, ManagerError, ManagerFatalError, ManagerThrottleError
+from virt import AbstractVirtReport
 
 
 class SubscriptionManagerError(ManagerError):
@@ -37,15 +38,23 @@ class SubscriptionManagerUnregisteredError(ManagerFatalError):
     pass
 
 
+# Mapping between strings returned from getJob and report statuses
+STATE_MAPPING = {
+    'FINISHED': AbstractVirtReport.STATE_FINISHED,
+    'CANCELED': AbstractVirtReport.STATE_CANCELED,
+    'FAILED': AbstractVirtReport.STATE_FAILED,
+    'RUNNING': AbstractVirtReport.STATE_PROCESSING,
+}
+
+
 class SubscriptionManager(Manager):
     smType = "sam"
 
     """ Class for interacting subscription-manager. """
-    def __init__(self, logger, options, addJob=None):
+    def __init__(self, logger, options):
         self.logger = logger
         self.options = options
         self.cert_uuid = None
-        self.addJob = addJob
 
         self.rhsm_config = rhsm_config.initConfig(rhsm_config.DEFAULT_CONFIG_PATH)
         self.readConfig()
@@ -180,30 +189,35 @@ class SubscriptionManager(Manager):
                 result = self.connection.hypervisorCheckIn(report.config.owner, report.config.env, serialized_mapping)
         except BadStatusLine:
             raise ManagerError("Communication with subscription manager interrupted")
+        except rhsm_connection.RateLimitExceededException as e:
+            self.retry_after = int(getattr(e, 'headers', {}).get('Retry-After'))
+            raise ManagerThrottleError(self.retry_after)
         except rhsm_connection.GoneException:
             raise ManagerError("Communication with subscription manager failed: consumer no longer exists")
         except rhsm_connection.ConnectionException as e:
-            self.logger.exception("Communication with server failed:")
-            if hasattr(e, 'code') and e.code >= 500:
+            if hasattr(e, 'code'):
                 raise ManagerError("Communication with subscription manager failed with code %d: %s" % (e.code, str(e)))
             raise ManagerError("Communication with subscription manager failed: %s" % str(e))
-        if (is_async is True and self.addJob is not None):
-            self.addJob(('checkJobStatus', [config, result['id']]))
+        if is_async is True:
+            report.state = AbstractVirtReport.STATE_PROCESSING
+            report.job_id = result['id']
+        else:
+            report.state = AbstractVirtReport.STATE_FINISHED
         return result
 
-    def checkJobStatus(self, config, job_id):
-        self._connect(config)
+    def check_report_state(self, report):
+        job_id = report.job_id
+        self._connect(report.config)
         self.logger.debug('Checking status of job %s', job_id)
         result = self.connection.getJob(job_id)
-        state = result['state']
-        if state not in ['FINISHED', 'CANCELED', 'FAILED']:
-            # This will cause virtwho to do this again later
-            self.addJob(('checkJobStatus', [config, result['id']]))
-            self.logger.debug('Job %s not finished, rescheduling', job_id)
+        state = STATE_MAPPING.get(result['state'], AbstractVirtReport.STATE_FAILED)
+        report.state = state
+        if state not in (AbstractVirtReport.STATE_FINISHED,
+                         AbstractVirtReport.STATE_CANCELED,
+                         AbstractVirtReport.STATE_FAILED):
+            self.logger.debug('Job %s not finished', job_id)
         else:
             # log completed job status
-            # TODO Make this its own method inside a class
-            # representing a status object
             resultData = result['resultData']
             if 'failedUpdate' in resultData:
                 for fail in resultData['failedUpdate']:
@@ -220,8 +234,6 @@ class SubscriptionManager(Manager):
                                      created['uuid'],
                                      ", ".join(guests))
             self.logger.info("Number of mappings unchanged: %d", len(resultData['unchanged']))
-            result = resultData
-        return result, state
 
     def uuid(self):
         """ Read consumer certificate and get consumer UUID from it. """
diff --git a/tests/test_virtwho.py b/tests/test_virtwho.py
index 63ffc98..4d00e64 100644
--- a/tests/test_virtwho.py
+++ b/tests/test_virtwho.py
@@ -26,15 +26,18 @@ from rhsm.connection import RestlibException
 
 from mock import patch, Mock, sentinel, ANY
 
-from virtwho import parseOptions, VirtWho, OptionError, Queue, Job
+from virtwho import parseOptions, VirtWho, OptionError, Queue
 from config import Config
 import util
-from virt import HostGuestAssociationReport, Hypervisor, Guest, DomainListReport
+from manager import ManagerThrottleError
+from virt import (
+    HostGuestAssociationReport, Hypervisor, Guest,
+    DomainListReport, AbstractVirtReport)
 from multiprocessing import Queue
 
 
 class TestOptions(TestBase):
-    NO_GENERAL_CONF = {'global':{}}
+    NO_GENERAL_CONF = {'global': {}}
 
     def setUp(self):
         self.clearEnv()
@@ -88,7 +91,7 @@ class TestOptions(TestBase):
         # Set the value in all three possible locations
         # Mock /etc/virt-who.conf file
         global_conf_dict = {
-            'global':{
+            'global': {
                 'reporter_id': "/etc/virt-who.conf"
             }
         }
@@ -111,7 +114,7 @@ class TestOptions(TestBase):
         _, options = parseOptions()
         self.assertEqual(options.reporter_id, "/etc/virt-who.conf")
 
-        parseFile.return_value = {'global':{}}
+        parseFile.return_value = {'global': {}}
 
         _, options = parseOptions()
         self.assertEqual(options.reporter_id, util.generateReporterId())
@@ -228,7 +231,6 @@ class TestOptions(TestBase):
                     if virt not in ('libvirt', 'vdsm') and missing != 'password':
                         if smType == 'satellite' and missing in ['env', 'owner']:
                             continue
-                        print(smType, virt, missing)
                         self.assertRaises(OptionError, parseOptions)
 
     @patch('log.getLogger')
@@ -262,47 +264,6 @@ class TestOptions(TestBase):
         fromOptions.assert_called_with(self.logger, options, ANY)
 
 
-class TestJobs(TestBase):
-    def setupVirtWho(self, oneshot=True):
-        options = Mock()
-        options.oneshot = oneshot
-        options.interval = 0
-        options.print_ = False
-        options.log_dir = ''
-        options.log_file = ''
-        virtwho = VirtWho(self.logger, options, config_dir="/nonexistant")
-        config = Config("test", "esx", server="localhost", username="username",
-                        password="password", owner="owner", env="env")
-        virtwho.configManager.addConfig(config)
-        return virtwho
-
-    @patch('log.getLogger')
-    def test_adding_job(self, getLogger):
-        virtwho = self.setupVirtWho()
-        # Mock out a method we want to call
-        virtwho.send = Mock()
-        fake_report = 'fake_report'
-        # Add an actual job to be executed immediately
-        test_job = Job('send', [fake_report])
-        virtwho.addJob(test_job)
-        virtwho.run()
-        virtwho.send.assert_called_with(fake_report)
-
-    @patch('log.getLogger')
-    def test_adding_tuple_of_job(self, getLogger):
-        # We should be able to pass in tuples like below and achieve the same
-        # result as if we passed in a Job object
-
-        # (target, [args], executeInSeconds, executeAfter)
-        fake_report = 'fakereport'
-        test_job_tuple = ('send', [fake_report])
-        virtwho = self.setupVirtWho()
-        virtwho.send = Mock()
-        virtwho.addJob(test_job_tuple)
-        virtwho.run()
-        virtwho.send.assert_called_with(fake_report)
-
-
 class TestSend(TestBase):
     def setUp(self):
         self.config = Config('config', 'esx', server='localhost',
@@ -338,9 +299,14 @@ class TestSend(TestBase):
         options.log_file = ''
         options.log_dir = ''
         virtwho = VirtWho(self.logger, options, config_dir="/nonexistant")
-        virtwho.send = Mock(wraps=virtwho.send)
+
+        def send(report):
+            report.state = AbstractVirtReport.STATE_FINISHED
+            return True
+        virtwho.send = Mock(side_effect=send)
         queue = Queue()
         virtwho.queue = queue
+        virtwho.retry_after = 1
         virtwho.configManager.addConfig(self.config)
         virtwho.configManager.addConfig(self.second_config)
         queue.put(self.fake_report)
@@ -348,13 +314,19 @@ class TestSend(TestBase):
         virtwho.run()
 
         self.assertEquals(virtwho.send.call_count, 2)
-        self.assertTrue(virtwho.reports[self.config.hash] == self.fake_report.hash)
-        self.assertTrue(virtwho.reports[self.second_config.hash] == self.fake_domain_list.hash)
+        self.assertEqual(virtwho.last_reports_hash[self.config.name], self.fake_report.hash)
+        self.assertEqual(virtwho.last_reports_hash[self.second_config.name], self.fake_domain_list.hash)
 
     @patch('log.getLogger')
     @patch('manager.Manager.fromOptions')
     @patch('virt.Virt.fromConfig')
-    def test_update_report_to_send(self, fromConfig, fromOptions, getLogger):
+    def test_same_report_filtering(self, fromConfig, fromOptions, getLogger):
+        def fake_virts(logger, config):
+            new_fake_virt = Mock()
+            new_fake_virt.config.name = config.name
+            return new_fake_virt
+
+        fromConfig.side_effect = fake_virts
         options = Mock()
         options.interval = 0
         options.oneshot = True
@@ -362,37 +334,33 @@ class TestSend(TestBase):
         options.log_dir = ''
         options.log_file = ''
         virtwho = VirtWho(self.logger, options, config_dir="/nonexistant")
-        report = Mock()
-        report.hash.return_value = "hash"
-        config = Mock()
-        report.config = config
-        config.hash.return_value = "config_hash"
-        config.name.return_value = "config_name"
-        self.assertTrue(virtwho.update_report_to_send(report))
-        self.assertTrue(len(virtwho.configs_ready) == 1 and
-                        config in virtwho.configs_ready)
-        self.assertTrue(virtwho.reports_to_send[config.hash].hash == report.hash)
-        # Pretend we sent the report for that config
-        virtwho.configs_ready = []
-        virtwho.reports[config.hash] = report.hash
-        del virtwho.reports_to_send[config.hash]
-
-        # if we receive the same report twice we should not send it
-        self.assertFalse(virtwho.update_report_to_send(report))
-        self.assertFalse(virtwho.configs_ready)
-        self.assertFalse(virtwho.reports_to_send)
+
+        queue = Queue()
+        # Create another report with same hash
+        report2 = HostGuestAssociationReport(self.config, self.fake_report.association)
+        self.assertEqual(self.fake_report.hash, report2.hash)
+
+        def send(report):
+            report.state = AbstractVirtReport.STATE_FINISHED
+            # Put second report when the first is done
+            queue.put(report2)
+            return True
+        virtwho.send = Mock(side_effect=send)
+        virtwho.queue = queue
+        virtwho.retry_after = 1
+        virtwho.configManager.addConfig(self.config)
+        queue.put(self.fake_report)
+        virtwho.run()
+
+        self.assertEquals(virtwho.send.call_count, 1)
 
     @patch('time.time')
     @patch('log.getLogger')
     @patch('manager.Manager.fromOptions')
     @patch('virt.Virt.fromConfig')
     def test_send_current_report(self, fromConfig, fromOptions, getLogger, time):
-        initial = 0
-        start_time = 0
-        end_time = 2
-        send_after_start_time = 0
-        expected_delta = end_time - start_time
-        time.side_effect = [initial, start_time, end_time, send_after_start_time]
+        initial = 10
+        time.side_effect = [initial, initial]
 
         fromOptions.return_value = Mock()
         options = Mock()
@@ -402,9 +370,7 @@ class TestSend(TestBase):
         options.log_dir = ''
         options.log_file = ''
         virtwho = VirtWho(Mock(), options, config_dir="/nonexistant")
-
-        expected_queue_timeout = max(0, options.interval - expected_delta)
-        expected_send_after = expected_queue_timeout + send_after_start_time
+        virtwho.oneshot_remaining = ['config_name']
 
         config = Mock()
         config.hash = "config_hash"
@@ -412,29 +378,30 @@ class TestSend(TestBase):
 
         virtwho.send = Mock()
         virtwho.send.return_value = True
-        virtwho.reports_to_send[config.hash] = sentinel.report
-        virtwho.configs_ready.append(config)
+        report = HostGuestAssociationReport(config, {'hypervisors': {}})
+        report.state = AbstractVirtReport.STATE_PROCESSING
+        virtwho.queued_reports[config.name] = report
+
+        virtwho.send_current_report()
 
-        result_config, result_report = virtwho.send_current_report()
+        def check_report_state(report):
+            report.state = AbstractVirtReport.STATE_FINISHED
+        virtwho.check_report_state = Mock(side_effect=check_report_state)
+        virtwho.check_reports_state()
 
-        self.assertEquals(expected_queue_timeout, virtwho.queue_timeout)
-        self.assertEquals(expected_send_after, virtwho.send_after)
-        self.assertEquals(config, result_config)
-        self.assertEquals(sentinel.report, result_report)
-        self.assertTrue(not virtwho.reports_to_send)
+        #self.assertEquals(expected_queue_timeout, virtwho.queue_timeout)
+        virtwho.send.assert_called_with(report)
+        self.assertEquals(virtwho.send_after, initial + 60)
 
     @patch('time.time')
     @patch('log.getLogger')
     @patch('manager.Manager.fromOptions')
     @patch('virt.Virt.fromConfig')
     def test_send_current_report_with_429(self, fromConfig, fromOptions, getLogger, time):
-        initial = 0
-        start_time = 0
-        end_time = 2
-        send_after_start_time = 0
+        initial = 10
         retry_after = 2
         expected_429_count = 1
-        time.side_effect = [initial, initial, start_time,  send_after_start_time]
+        time.side_effect = [initial, initial]
 
         fromOptions.return_value = Mock()
         options = Mock()
@@ -445,24 +412,20 @@ class TestSend(TestBase):
         options.log_file = ''
         virtwho = VirtWho(Mock(), options, config_dir="/nonexistant")
 
-        expected_queue_timeout = retry_after ** expected_429_count
-        expected_send_after = expected_queue_timeout + send_after_start_time
-
         config = Mock()
         config.hash = "config_hash"
         config.name = "config_name"
-        virtwho.configs_ready.append(config)
-        virtwho.reports_to_send[config.hash] = sentinel.report
+
+        report = HostGuestAssociationReport(config, {})
+        report.state = AbstractVirtReport.STATE_PROCESSING
+        virtwho.queued_reports[config.name] = report
 
         virtwho.send = Mock()
         virtwho.send.return_value = False
-        virtwho.send.side_effect = RestlibException("429", "429", {"Retry-After": retry_after})
+        virtwho.send.side_effect = ManagerThrottleError(retry_after)
 
-        result_config, result_report = virtwho.send_current_report()
+        virtwho.send_current_report()
 
-        self.assertEquals(expected_queue_timeout, virtwho.queue_timeout)
-        self.assertEquals(expected_send_after, virtwho.send_after)
-        self.assertEquals(result_config, config)
-        self.assertEquals(None, result_report)
-        self.assertEquals(len(virtwho.reports_to_send), 1)
-        self.assertTrue(config in virtwho.configs_ready)
+        virtwho.send.assert_called_with(report)
+        self.assertEquals(virtwho.send_after, initial + retry_after)
+        self.assertEquals(len(virtwho.queued_reports), 1)
diff --git a/virt/virt.py b/virt/virt.py
index 6153ded..feef635 100644
--- a/virt/virt.py
+++ b/virt/virt.py
@@ -144,18 +144,38 @@ class AbstractVirtReport(object):
     '''
     An abstract report from virt backend.
     '''
+    # The report was just collected, but is not yet being reported
+    STATE_CREATED = 1
+    # The report is being processed by server
+    STATE_PROCESSING = 2
+    # The report has been processed by server
+    STATE_FINISHED = 3
+    # Failed to process the report by server
+    STATE_FAILED = 4
+    # Processing the report on server was canceled
+    STATE_CANCELED = 5
+
     def __init__(self, config):
         self._config = config
+        self._state = AbstractVirtReport.STATE_CREATED
 
     @property
     def config(self):
         return self._config
 
+    @property
+    def state(self):
+        return self._state
+
+    @state.setter
+    def state(self, value):
+        self._state = value
+
 
 class ErrorReport(AbstractVirtReport):
     '''
     Report that virt backend fails. Used in oneshot mode to inform
-    main process that now data are coming.
+    main process that no data are coming.
     '''
 
 
diff --git a/virtwho.py b/virtwho.py
index a5b1c9c..a130b4d 100644
--- a/virtwho.py
+++ b/virtwho.py
@@ -27,7 +27,6 @@ from multiprocessing import Event, Queue
 import json
 
 from Queue import Empty
-from rhsm.connection import RestlibException
 
 try:
     from collections import OrderedDict
@@ -36,8 +35,8 @@ except ImportError:
     from util import OrderedDict
 
 from daemon import daemon
-from virt import Virt, DomainListReport, HostGuestAssociationReport, ErrorReport
-from manager import Manager, ManagerError, ManagerFatalError
+from virt import Virt, AbstractVirtReport, DomainListReport, HostGuestAssociationReport, ErrorReport
+from manager import Manager, ManagerError, ManagerFatalError, ManagerThrottleError
 from manager.subscriptionmanager import SubscriptionManager
 from config import Config, ConfigManager, InvalidPasswordFormat, GlobalConfig, NotSetSentinel, VIRTWHO_GENERAL_CONF_PATH
 from password import InvalidKeyFile
@@ -54,24 +53,6 @@ except ImportError:
         pass
 
 
-class Job(object):
-    """
-    This class represents a job to be run
-    Parameters:
-        'target': this is the method to be executed with 'args' arguments
-        'args': OPTIONAL the arguments list to be passed to 'target'
-    """
-    def __init__(self,
-                 target,
-                 args=None):
-        self.target = target
-
-        if args is None:
-            self.args = []
-        else:
-            self.args = args
-
-
 class ReloadRequest(Exception):
     ''' Reload of virt-who was requested by sending SIGHUP signal. '''
 
@@ -97,8 +78,6 @@ class OptionParserEpilog(OptionParser):
 # Default interval for sending list of UUIDs
 DefaultInterval = 60  # One per minute
 MinimumSendInterval = 60  # One minute
-# How many seconds to wait until attempting to send a report again
-RetryAfter = 2
 
 PIDFILE = "/var/run/virt-who.pid"
 SAT5 = "satellite"
@@ -121,95 +100,90 @@ class VirtWho(object):
 
         # Queue for getting events from virt backends
         self.queue = None
-        # How long should we wait for new item in queue, it depends on
-        # jobs we have and how long we have them
-        self.queue_timeout = None
-        # a heap to manage the jobs we have incoming
-        self.jobs = []
-        # A dictionary of hashs of reports previously sent
-        self.reports = {}
-        # a list of configs that have reports ready to send
-        self.configs_ready = []
-        # A dictionary of reports to send
-        self.reports_to_send = {}
+
+        # Dictionary with mapping between config names and report hashes,
+        # used for checking if the report changed from last time
+        self.last_reports_hash = {}
+        # How long should we wait between reports sent to server
+        self.retry_after = max(MinimumSendInterval, options.interval)
         # This counts the number of responses of http code 429
         # received between successfully sent reports
         self._429_count = 0
         self.reloading = False
 
-        self.configManager = ConfigManager(self.logger,
-                                           config_dir)
+        # Reports that are queued for sending
+        self.queued_reports = OrderedDict()
+
+        # Name of configs that wasn't reported in oneshot mode
+        self.oneshot_remaining = set()
+
+        # Reports that are currently processed by server
+        self.reports_in_progress = []
+
+        self.configManager = ConfigManager(self.logger, config_dir)
 
         for config in self.configManager.configs:
             logger.debug("Using config named '%s'" % config.name)
 
         self.send_after = time.time()
 
-    def addJob(self, job):
-        # Add a job to be executed next time we have a report to send
-        if (not isinstance(job, Job)):
-            job = Job(*job)
-        self.jobs.append(job)
+    def check_report_state(self, report):
+        ''' Check state of one report that is being processed on server. '''
+        manager = Manager.fromOptions(self.logger, self.options, report.config)
+        manager.check_report_state(report)
 
-    def runJobs(self):
-        if not self.jobs:
+    def check_reports_state(self):
+        ''' Check status of the reports that are being processed on server. '''
+        if not self.reports_in_progress:
             return
-        # Run only those jobs added before this method was called
-        # This prevents any issues with jobs that result in the creation of
-        # another job
-        jobsToRun = self.jobs
-        self.jobs = []
-        for job in jobsToRun:
-            if hasattr(self, job.target):
-                self.logger.debug('Running method "%s"', job.target)
-                try:
-                    getattr(self, job.target)(*job.args)
-                except Exception:
-                    self.logger.exception("Job failed:")
+        updated = []
+        finished = False
+        for report in self.reports_in_progress:
+            self.check_report_state(report)
+            if report.state == AbstractVirtReport.STATE_CREATED:
+                self.logger.warning("Can't check status of report that is not yet sent")
+            elif report.state == AbstractVirtReport.STATE_PROCESSING:
+                updated.append(report)
             else:
-                self.logger.debug('VirtWho has no method "%s"', job.target)
-
-    def reportChanged(self, report):
-        return report.hash != self.reports.get(report.config.hash)
+                self.report_done(report)
+                finished = True
+        self.reports_in_progress = updated
 
-    def _get_current_report(self):
-        if not self.configs_ready:
-            return None, None
-        config = self.configs_ready.pop(0)
-        report = self.reports_to_send.get(config.hash)
-        return config, report
+        # We've just finished sending last report, we can send next one after
+        # backend interval
+        if finished and not updated:
+            self.send_after = time.time() + self.retry_after
 
     def send_current_report(self):
-        report_sent = None
-        config = None
+        name, report = self.queued_reports.popitem(last=False)
+
         try:
-            config, report_to_send = self._get_current_report()
-            start_time = time.time()
-            if report_to_send and self.send(report_to_send):
-                # Reset the count of 429's between successful sends
-                self._429_count = 0
-                report_sent = report_to_send
-            delta = time.time() - start_time
-            self.queue_timeout = max(0,  self.options.interval - delta)
-        except RestlibException as e:
-            if e.code in ['429']:
-                # We've exceeded the rate limit
-                self._429_count += 1
-                retry_after = getattr(e, 'headers', {}).get('Retry-After') \
-                    or RetryAfter
-                self.queue_timeout = (retry_after ** self._429_count)
-                self.logger.debug('429 received, waiting %s seconds until sending again', self.queue_timeout)
+            if self.send(report):
+                self.logger.debug('Report for config "%s" sent', name)
+                if report.state == AbstractVirtReport.STATE_PROCESSING:
+                    self.reports_in_progress.append(report)
+                else:
+                    self.report_done(report)
             else:
-                self.queue_timeout = max(0,  self.options.interval)
-
-        if report_sent:
-            self.logger.debug('Report for config "%s" sent', config.name)
-            del self.reports_to_send[config.hash]
-        elif config:
-            self.configs_ready.append(config)
-
-        self.send_after = time.time() + self.queue_timeout
-        return config, report_sent
+                report.state = AbstractVirtReport.STATE_FAILED
+                self.logger.debug('Report from "%s" failed to sent', name)
+                self.report_done(report)
+        except ManagerThrottleError as e:
+            self.queued_reports[name] = report
+            self.retry_after = e.retry_after
+            self.send_after = time.time() + self.retry_after
+            self.logger.debug('429 received, waiting %s seconds until sending again', e.retry_after)
+
+    def report_done(self, report):
+        name = report.config.name
+        if report.state == AbstractVirtReport.STATE_FINISHED:
+            self.last_reports_hash[name] = report.hash
+
+        if self.options.oneshot:
+            try:
+                self.oneshot_remaining.remove(name)
+            except KeyError:
+                pass
 
     def send(self, report):
         """
@@ -231,7 +205,7 @@ class VirtWho(object):
             # Something really bad happened (system is not register), stop the backends
             self.logger.exception("Error in communication with subscription manager:")
             raise
-        except RestlibException as e:
+        except ManagerThrottleError:
             raise
         except Exception as e:
             if self.reloading:
@@ -248,35 +222,10 @@ class VirtWho(object):
         manager = Manager.fromOptions(self.logger, self.options, report.config)
         manager.sendVirtGuests(report, self.options)
         self.logger.info("virt-who guest list update successful")
-        self.reports[report.config.hash] = report.hash
 
     def _sendGuestAssociation(self, report):
         manager = Manager.fromOptions(self.logger, self.options, report.config)
-        manager.addJob = self.addJob
         manager.hypervisorCheckIn(report, self.options)
-        self.reports[report.config.hash] = report.hash
-
-    def update_report_to_send(self, report):
-        """
-        Updates the reports to send dict with the given report (provided there are changes detected).
-        Returns a boolean of if there were any changes
-        """
-        if hasattr(report, 'hash') and not self.reportChanged(report):
-            self.logger.info('No change in report gathered using config: "%s", report not sent.', report.config.name)
-            return False
-        self.reports_to_send[report.config.hash] = report
-        if report.config not in self.configs_ready:
-            # Mark this config as one that is ready to be sent
-            self.configs_ready.append(report.config)
-        self.logger.debug('Report for config "%s" updated', report.config.name)
-        return True
-
-    def checkJobStatus(self, config, job_id):
-        manager = SubscriptionManager(self.logger, self.options, self.addJob)
-        result, state = manager.checkJobStatus(config, job_id)
-
-        if state == 'FINISHED':
-            self.logger.info("virt-who host/guest association update successful")
 
     def run(self):
         self.reloading = False
@@ -299,24 +248,38 @@ class VirtWho(object):
             # Run the process
             virt.start(self.queue, self.terminate_event, self.options.interval, self.options.oneshot)
             self.virts.append(virt)
-        if self.options.oneshot or self.options.print_:
-            oneshot_remaining = set(virt.config.name for virt in self.virts)
+        if self.options.oneshot:
+            self.oneshot_remaining = set(virt.config.name for virt in self.virts)
 
         if len(self.virts) == 0:
             self.logger.error("No suitable virt backend found")
             return
 
-        result = {}
-        report = None
-        report_sent = None
+        # queued reports depend on OrderedDict feature that if key exists
+        # when setting an item, it will remain in the same order
+        self.queued_reports.clear()
+
+        # List of reports that are being processed by server
+        self.reports_in_progress = []
+
         while not self.terminate_event.is_set():
-            if self.jobs:
-                # There is an existing job, we want to check it's state often
+            if self.reports_in_progress:
+                # Check sent report status regularly
                 timeout = 1
+            elif time.time() > self.send_after:
+                if self.queued_reports:
+                    # Reports are queued and we can send them right now,
+                    # don't wait in queue
+                    timeout = 0
+                else:
+                    # No reports in progress or queued and we can send report
+                    # immediately, we can wait for report as long as we want
+                    timeout = 3600
             else:
-                timeout = self.queue_timeout
+                # We can't send report right now, wait till we can
+                timeout = max(1, self.send_after - time.time())
 
-            # Wait for incoming report from virt backend
+            # Wait for incoming report from virt backend or for timeout
             try:
                 report = self.queue.get(block=True, timeout=timeout)
             except Empty:
@@ -324,81 +287,58 @@ class VirtWho(object):
             except IOError:
                 continue
 
-            # Read all the reports from the queue in order to remove obsoleted
-            # reports from same virt
-            reports = [report]
+            # Read rest of the reports from the queue in order to remove
+            # obsoleted reports from same virt
             while True:
+                if isinstance(report, ErrorReport):
+                    if self.options.oneshot:
+                        # Don't hang on the failed backend
+                        try:
+                            self.oneshot_remaining.remove(report.config.name)
+                        except KeyError:
+                            pass
+                        self.logger.warn('Unable to collect report for config "%s"', report.config.name)
+                elif isinstance(report, AbstractVirtReport):
+                    if self.last_reports_hash.get(report.config.name, None) == report.hash:
+                        self.logger.info('Report for config "%s" didn\'t change, not sending', report.config.name)
+                    else:
+                        self.queued_reports[report.config.name] = report
+                        if self.options.print_:
+                            try:
+                                self.oneshot_remaining.remove(report.config.name)
+                            except KeyError:
+                                pass
+                elif report in ['exit', 'reload']:
+                    # Reload and exit reports takes priority, do not process
+                    # any other reports
+                    break
                 try:
                     report = self.queue.get(block=False)
-                    reports.append(report)
                 except Empty:
                     break
-            reports = self._remove_obsolete(reports)
 
-            try:
-                # Run all jobs that have been queued as a result of sending last
-                # time
-                self.runJobs()
-                if self.options.oneshot and not oneshot_remaining and not self.jobs:
-                    break
-            except Empty:
-                pass
-            except IOError:
-                pass
-
-            report_sent = None
-            for report in reports:
-                if report == "exit":
-                    break
-                if report == "reload":
-                    self.stop_virts()
-                    raise ReloadRequest()
-                if isinstance(report, ErrorReport):
-                    if self.options.oneshot:
-                        # Don't hang on the failed backend
-                        oneshot_remaining.remove(report.config.name)
-                        self.logger.warn('Unable to collect report for config "%s"', report.config.name)
-                # Send the report
-                if not self.options.print_ and not isinstance(report, ErrorReport):
-                    self.update_report_to_send(report)
-            # Check to see if it is time to send a report
-            try:
-                if time.time() >= self.send_after:
-                    # It is time, send the current report
-                    config, report_sent = self.send_current_report()
-                else:
-                    # It's not time update our queue_timeout to make sure we
-                    # don't wait too long
-                    wait_time = self.send_after - time.time()
-                    self.queue_timeout = max(0, wait_time)
-            except ManagerFatalError:
-                # System not register (probably), stop the backends
+            if report == 'exit':
+                break
+            elif report == 'reload':
                 self.stop_virts()
-                continue
+                raise ReloadRequest()
 
-            if self.options.print_:
-                report_sent = report
+            self.check_reports_state()
+
+            if not self.reports_in_progress and self.queued_reports and time.time() > self.send_after:
+                # No report is processed, send next one
+                if not self.options.print_:
+                    self.send_current_report()
+
+            if self.options.oneshot and not self.oneshot_remaining:
+                break
 
-            if (self.options.oneshot and report_sent) or self.options.print_:
-                try:
-                    oneshot_remaining.remove(report_sent.config.name)
-                except KeyError:
-                    pass
-                if not isinstance(report_sent, ErrorReport):
-                    if self.options.print_:
-                        result[report_sent.config] = report_sent
-                for virt in self.virts:
-                    if virt.config.name == report_sent.config.name:
-                        virt.stop()
-                if not oneshot_remaining and not self.jobs:
-                    break
         self.queue = None
-        self.jobs = None
         self.stop_virts()
 
         self.virt = []
         if self.options.print_:
-            return result
+            return self.queued_reports
 
     def stop_virts(self):
         for virt in self.virts:
@@ -434,7 +374,6 @@ class VirtWho(object):
         # Set the terminate event in all the virts
         for virt in self.virts:
             virt.stop()
-        self.reports = {}
         # clear the queue and put "reload" there
         try:
             while True:
@@ -444,28 +383,6 @@ class VirtWho(object):
         self.reloading = True
         self.queue.put("reload")
 
-    def getMapping(self):
-        mapping = {}
-        for config in self.configManager.configs:
-            logger = log.getLogger(config=config)
-            virt = Virt.fromConfig(logger, config)
-            mapping[config.name or 'none'] = self._readGuests(virt)
-        return mapping
-
-    def _remove_obsolete(self, reports):
-        reports_dict = OrderedDict()
-        for report in reports:
-            if report is None:
-                continue
-
-            if report in ['exit', 'reload']:
-                # Throw away all other reports when report is 'exit' or 'reload'
-                return [report]
-
-            reports_dict[report.config.name] = report
-
-        return reports_dict.values()
-
 
 def exceptionCheck(e):
     try:
@@ -401,10 +401,10 @@ def parseOptions():
     parser = OptionParserEpilog(usage="virt-who [-d] [-i INTERVAL] [-o] [--sam|--satellite5|--satellite6] [--libvirt|--vdsm|--esx|--rhevm|--hyperv]",
                                 description="Agent for reporting virtual guest IDs to subscription manager",
                                 epilog="virt-who also reads enviroment variables. They have the same name as command line arguments but uppercased, with underscore instead of dash and prefixed with VIRTWHO_ (e.g. VIRTWHO_ONE_SHOT). Empty variables are considered as disabled, non-empty as enabled")
-    parser.add_option("-d", "--debug", action="store_true", dest="debug", default=NotSetSentinel(), help="Enable debugging output")
-    parser.add_option("-o", "--one-shot", action="store_true", dest="oneshot", default=NotSetSentinel(), help="Send the list of guest IDs and exit immediately")
+    parser.add_option("-d", "--debug", action="store_true", dest="debug", default=False, help="Enable debugging output")
+    parser.add_option("-o", "--one-shot", action="store_true", dest="oneshot", default=False, help="Send the list of guest IDs and exit immediately")
     parser.add_option("-i", "--interval", type="int", dest="interval", default=NotSetSentinel(), help="Acquire list of virtual guest each N seconds. Send if changes are detected.")
-    parser.add_option("-p", "--print", action="store_true", dest="print_", default=NotSetSentinel(), help="Print the host/guest association obtained from virtualization backend (implies oneshot)")
+    parser.add_option("-p", "--print", action="store_true", dest="print_", default=False, help="Print the host/guest association obtained from virtualization backend (implies oneshot)")
     parser.add_option("-c", "--config", action="append", dest="configs", default=[], help="Configuration file that will be processed, can be used multiple times")
     parser.add_option("-m", "--log-per-config", action="store_true", dest="log_per_config", default=NotSetSentinel(), help="Write one log file per configured virtualization backend.\nImplies a log_dir of %s/virtwho (Default: all messages are written to a single log file)" % log.DEFAULT_LOG_DIR)
     parser.add_option("-l", "--log-dir", action="store", dest="log_dir", default=log.DEFAULT_LOG_DIR, help="The absolute path of the directory to log to. (Default '%s')" % log.DEFAULT_LOG_DIR)
@@ -593,9 +510,6 @@ def parseOptions():
     if env in ["1", "true"]:
         options.oneshot = True
 
-    if options.print_:
-        options.oneshot = True
-
     env = os.getenv("VIRTWHO_INTERVAL")
     if env:
         env = env.strip().lower()
@@ -653,7 +567,6 @@ def parseOptions():
     options.update(**getNonDefaultOptions(vars(cli_options), parser.defaults))
 
     # Check Env
-
     def checkEnv(variable, option, name, required=True):
         """
         If `option` is empty, check enviroment `variable` and return its value.
@@ -728,6 +641,9 @@ def parseOptions():
             logger.warning("Interval value may not be set below the default of %d seconds. Will use default value.", MinimumSendInterval)
         options.interval = MinimumSendInterval
 
+    if options.print_:
+        options.oneshot = True
+
     logger.info("Using reporter_id='%s'", options.reporter_id)
     return (logger, options)
 
@@ -880,8 +796,8 @@ def exit(code, status=None):
 
     if virtWho:
         virtWho.terminate()
-    queueLogger = log.getQueueLogger()
-    if queueLogger:
+    if log.hasQueueLogger():
+        queueLogger = log.getQueueLogger()
         queueLogger.terminate()
     sys.exit(code)
 
