commit 73c3755d1a40b768baf3c6ece95e8d304dee5734
Author: Radek Novacek <rnovacek@redhat.com>
Date:   Tue Jan 26 14:54:01 2016 +0100

    HyperV: support ntlm sealing and signing
    
    The ntlm module has to be reimplemented to support NTLM signing and
    sealing. Communication with HyperV is now encrypted by default.

diff --git a/requirements.txt b/requirements.txt
index c7a3e96..83261e7 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,2 +1,4 @@
 suds>=0.4.0
 git+https://github.com/candlepin/python-rhsm#egg=rhsm
+requests>=2.0
+
diff --git a/virt-who.spec b/virt-who.spec
index d796a20..f33eea7 100644
--- a/virt-who.spec
+++ b/virt-who.spec
@@ -18,6 +18,7 @@ Requires:       python-rhsm >= 1.10.10
 Requires:       python-suds
 # m2crypto is required for Hyper-V support
 Requires:       m2crypto
+Requires:       python-requests
 Requires(post): chkconfig
 Requires(preun): chkconfig
 # This is for /sbin/service
diff --git a/virt/hyperv/hyperv.py b/virt/hyperv/hyperv.py
index c25f6f3..e4e2642 100644
--- a/virt/hyperv/hyperv.py
+++ b/virt/hyperv/hyperv.py
@@ -20,10 +20,14 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 
 import sys
 import os
+import re
 import httplib
 import urlparse
 import base64
+import struct
 from xml.etree import ElementTree
+from requests.auth import AuthBase
+import requests
 
 import virt
 
@@ -39,6 +43,169 @@ except ImportError:
         return subprocess.Popen(["uuidgen"], stdout=subprocess.PIPE).communicate()[0].strip()
 
 
+class HyperVAuth(AuthBase):
+    def __init__(self, username, password, logger):
+        self.username = username
+        self.password = password
+        self.logger = logger
+        self.authenticated = False
+        self.ignore_ntlm = False
+        self.num_401s = 0
+        self.ntlm = None
+        self.basic = None
+
+    def prepare_resend(self, response):
+        '''
+        Consume content and release the original connection
+        to allow our new request to reuse the same one.
+        '''
+        response.content
+        response.raw.release_conn()
+        return response.request.copy()
+
+    def retry_ntlm_negotitate(self, response, **kwargs):
+        self.logger.debug("Using NTLM authentication")
+
+        request = self.prepare_resend(response)
+
+        self.ntlm = ntlm.Ntlm()
+        negotiate = base64.b64encode(self.ntlm.negotiate_message(self.username))
+        request.headers["Authorization"] = "Negotiate %s" % negotiate
+        r = response.connection.send(request, **kwargs)
+        if r.status_code != 401:
+            raise HyperVAuthFailed("NTLM authentication failed, unexpected error code %d" % r.status_code)
+        return self.retry_ntlm_authenticate(r, **kwargs)
+
+    def retry_ntlm_authenticate(self, response, **kwargs):
+        self.logger.debug("Sending NTLM authentication data")
+
+        request = self.prepare_resend(response)
+
+        auth_header = response.headers.get("www-authenticate", '')
+        nego, challenge = auth_header.split(" ", 1)
+        if nego != "Negotiate":
+            self.logger.warning("Wrong ntlm header: %s", auth_header)
+
+        negotiate = base64.b64encode(self.ntlm.authentication_message(base64.b64decode(challenge), self.password))
+        request.headers["Authorization"] = "Negotiate %s" % negotiate
+
+        # Encrypt body of original request and include it
+        request.body = self._body
+        request.headers['Content-Length'] = len(self._body)
+
+        self.encrypt_request(request)
+
+        r = response.connection.send(request, **kwargs)
+        if r.status_code == 401:
+            raise HyperVAuthFailed("Incorrect domain/username/password")
+        else:
+            self.authenticated = True
+            self.logger.debug("NTLM authentication successful")
+
+        return self.decrypt_response(r)
+
+    def encrypt_request(self, request):
+        # Seal the message
+        encrypted, signature = self.ntlm.encrypt(request.body)
+
+        boundary = 'Encrypted Boundary'
+        body = b'''--{boundary}\r
+Content-Type: application/HTTP-SPNEGO-session-encrypted\r
+OriginalContent: type={original};Length={length}\r
+--{boundary}\r
+Content-Type: application/octet-stream\r
+{header_len}{signature}{encrypted}--{boundary}--\r
+'''.format(
+            original=request.headers["Content-Type"],
+            length=len(encrypted),
+            header_len=struct.pack('<I', len(signature)),
+            signature=signature,
+            encrypted=encrypted,
+            boundary=boundary)
+        request.headers["Content-Type"] = (
+            'multipart/encrypted;'
+            'protocol="application/HTTP-SPNEGO-session-encrypted";'
+            'boundary="{boundary}"').format(boundary=boundary)
+        request.body = body
+        request.headers["Content-Length"] = len(body)
+        return request
+
+    def decrypt_response(self, response):
+        # See `encrypt_request` method for format of the response
+        content_type = response.headers.get('Content-Type', 'text/xml')
+        if 'multipart/encrypted' not in content_type:
+            # The response is not encrypted, just return it
+            return response
+        data = response.raw.read(response.headers.get('Content-Length', 0))
+        parts = re.split(r'-- ?Encrypted Boundary', data)
+        try:
+            body = parts[2].lstrip('\r\n').split('\r\n', 1)[1]
+        except IndexError:
+            self.logger.debug("Incorrect multipart data: %s", data)
+            raise HyperVAuthFailed("Unable to decrypt sealed response: incorrect format")
+        # First four bytes of body is signature length
+        l = struct.unpack('<I', body[:4])[0]
+        # Then there is signature with given length
+        signature = body[4:4 + l]
+        # Message body follows
+        msg = body[4 + l:]
+        # Decrypt it
+        decrypted = self.ntlm.decrypt(msg, signature)
+        response._content = decrypted
+        return response
+
+    def retry_basic(self, response, **kwargs):
+        self.logger.debug("Using Basic authentication")
+
+        request = self.prepare_resend(response)
+
+        passphrase = '%s:%s' % (self.username, self.password)
+        self.basic = 'Basic %s' % base64.b64encode(passphrase)
+        request.headers['Authorization'] = self.basic
+        request.headers['Content-Length'] = len(self._body)
+        request.body = self._body
+        r = response.connection.send(request, **kwargs)
+        if r.status_code == requests.codes.ok:
+            self.authenticated = True
+        return r
+
+    def handle_response(self, response, **kwargs):
+        if self.authenticated and self.ntlm:
+            # If we're authenticated and have ntlm object, the body might be sealed
+            return self.decrypt_response(response)
+        if response.status_code == requests.codes.ok and not self.authenticated:
+            self.authenticated = True
+            response.request.body = self._body
+            r = response.connection.send(response.request, **kwargs)
+            return r
+
+        if response.status_code == 401:
+            authenticate_header = response.headers.get('www-authenticate', '').lower()
+            if 'negotiate' in authenticate_header and not self.ignore_ntlm:
+                return self.retry_ntlm_negotitate(response, **kwargs)
+            elif 'basic' in authenticate_header:
+                return self.retry_basic(response, **kwargs)
+            else:
+                raise HyperVAuthFailed(
+                    "Server doesn't known any supported authentication method "
+                    "(server methods: %s)" % authenticate_header)
+        return response
+
+    def __call__(self, request):
+        request.headers["Connection"] = "Keep-Alive"
+        if not self.authenticated:
+            request.headers["Content-Length"] = "0"
+            self._body = request.body
+            request.body = None
+            request.register_hook('response', self.handle_response)
+        elif self.ntlm:
+            request.register_hook('response', self.handle_response)
+            return self.encrypt_request(request)
+        elif self.basic:
+            request.headers['Authorization'] = self.basic
+        return request
+
+
 class HyperVSoapGenerator(object):
     def __init__(self, url):
         self.url = url
@@ -146,32 +313,35 @@ ENABLED_STATE_TO_GUEST_STATE = {
 
 
 class HyperVSoap(object):
-    def __init__(self, url, connection, headers, logger):
+    def __init__(self, url, connection, logger):
         self.url = url
         self.connection = connection
-        self.headers = headers
         self.generator = HyperVSoapGenerator(self.url)
         self.logger = logger
 
     def post(self, body):
-        self.headers["Content-Length"] = "%d" % len(body)
-        self.headers["Content-Type"] = "application/soap+xml;charset=UTF-8"
-        self.connection.request("POST", self.url, body=body, headers=self.headers)
-        response = self.connection.getresponse()
-        if response.status == 401:
+        headers = {
+            "Content-Type": "application/soap+xml;charset=UTF-8"
+        }
+        response = self.connection.post(self.url, body, headers=headers)
+        data = response.text
+        if response.status_code == 401:
             raise HyperVAuthFailed("Authentication failed")
-        if response.status != 200:
-            data = response.read()
+        if 400 <= response.status_code < 500:
+            raise HyperVException("Communication with Hyper-V failed, HTTP error: %d" % response.status_code)
+        elif response.status_code == 500:
+            raise HyperVCallFailed("Hyper-V call failed, HTTP error: %d" % response.status_code)
+        if response.status_code != requests.codes.ok:
             xml = ElementTree.fromstring(data)
             errorcode = xml.find('.//{http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/MSFT_WmiError}error_Code')
             # Suppress reporting of invalid namespace, because we're testing
             # both old and new namespaces that HyperV uses
             if errorcode is None or errorcode.text != '2150858778':
-                self.logger.debug("Invalid response (%d) from Hyper-V: %s", response.status, data)
-            raise HyperVException("Communication with Hyper-V failed, HTTP error: %d" % response.status)
+                self.logger.debug("Invalid response (%d) from Hyper-V: %s", response.status_code, data)
+            raise HyperVException("Communication with Hyper-V failed, HTTP error: %d" % response.status_code)
         if response is None:
             raise HyperVException("No reply from Hyper-V")
-        return response
+        return data
 
     @classmethod
     def _Instance(cls, xml):
@@ -188,9 +358,8 @@ class HyperVSoap(object):
 
     def Enumerate(self, query, namespace="root/virtualization"):
         data = self.generator.enumerateXML(query=query, namespace=namespace)
-        response = self.post(data)
-        d = response.read()
-        xml = ElementTree.fromstring(d)
+        body = self.post(data)
+        xml = ElementTree.fromstring(body)
         if xml.tag != "{%(s)s}Envelope" % self.generator.namespaces:
             raise HyperVException("Wrong reply format")
         responses = xml.findall("{%(s)s}Body/{%(wsen)s}EnumerateResponse" % self.generator.namespaces)
@@ -206,9 +375,8 @@ class HyperVSoap(object):
 
     def _PullOne(self, uuid, namespace):
         data = self.generator.pullXML(enumerationContext=uuid, namespace=namespace)
-        response = self.post(data)
-        d = response.read()
-        xml = ElementTree.fromstring(d)
+        body = self.post(data)
+        xml = ElementTree.fromstring(body)
         if xml.tag != "{%(s)s}Envelope" % self.generator.namespaces:
             raise HyperVException("Wrong reply format")
         responses = xml.findall("{%(s)s}Body/{%(wsen)s}PullResponse" % self.generator.namespaces)
@@ -240,9 +408,8 @@ class HyperVSoap(object):
         return dict where `ElementName` is key and `virt.GUEST.STATE_*` is value.
         '''
         data = self.generator.getSummaryInformationXML(namespace)
-        response = self.post(data)
-        d = response.read()
-        xml = ElementTree.fromstring(d)
+        body = self.post(data)
+        xml = ElementTree.fromstring(body)
         if xml.tag != "{%(s)s}Envelope" % self.generator.namespaces:
             raise HyperVException("Wrong reply format")
         responses = xml.findall("{%(s)s}Body/{%(vsms)s}GetSummaryInformation_OUTPUT" % {
@@ -269,6 +436,10 @@ class HyperVAuthFailed(HyperVException):
     pass
 
 
+class HyperVCallFailed(HyperVException):
+    pass
+
+
 class HyperV(virt.Virt):
     CONFIG_TYPE = "hyperv"
 
@@ -301,115 +472,12 @@ class HyperV(virt.Virt):
 
         logger.debug("Hyper-V url: %s", self.url)
 
-        # Check if we have domain defined and set flags accordingly
-        user_parts = self.username.split('\\', 1)
-        if len(user_parts) == 1:
-            self.username = user_parts[0]
-            self.domainname = ''
-            self.type1_flags = ntlm.NTLM_TYPE1_FLAGS & ~ntlm.NTLM_NegotiateOemDomainSupplied
-        else:
-            self.domainname = user_parts[0].upper()
-            self.username = user_parts[1]
-            self.type1_flags = ntlm.NTLM_TYPE1_FLAGS
-
     def connect(self):
-        host, port = self.host.split(':')
-        proxy = False
-        protocol = self.url.partition("://")[0]
-        for env in ['%s_proxy' % protocol.lower(), '%s_PROXY' % protocol.upper()]:
-            if env in os.environ:
-                proxy_url = os.environ[env]
-                if "://" not in proxy_url:
-                    # Add http or https to proxy_url otherwise urlsplit
-                    # won't parse it correctly
-                    proxy_url = "%s://%s" % (protocol, proxy_url)
-                r = urlparse.urlsplit(proxy_url)
-                host = r.hostname
-                port = r.port or (80 if protocol == 'http' else 443)
-                proxy = True
-                break
-
-        if protocol == "https":
-            connection = httplib.HTTPSConnection(host, int(port))
-        else:
-            connection = httplib.HTTPConnection(host, int(port))
-
-        if proxy and proxy_url.startswith('https'):
-            connection.request("CONNECT", self.host)
-            response = connection.getresponse()
-
-        headers = {}
-        headers["Connection"] = "Keep-Alive"
-        headers["Proxy-Connection"] = "Keep-Alive"
-        headers["Content-Length"] = "0"
-        headers["Host"] = self.host
-
-        connection.request("POST", self.url, headers=headers)
-        response = connection.getresponse()
-        response.read()
-
-        if response.status == 200:
-            return connection, headers
-        elif response.status == 404:
-            raise HyperVException("Invalid HyperV url: %s" % self.url)
-        elif response.status != 401:
-            raise HyperVException("Unable to connect to HyperV at: %s" % self.url)
-        # 401 - need authentication
-
-        authenticate_header = response.getheader("WWW-Authenticate", "")
-        if 'Negotiate' in authenticate_header:
-            try:
-                self.ntlmAuth(connection, headers)
-            except HyperVAuthFailed:
-                if 'Basic' in authenticate_header:
-                    self.basicAuth(connection, headers)
-                else:
-                    raise
-        elif 'Basic' in authenticate_header:
-            self.basicAuth(connection, headers)
-        else:
-            raise HyperVAuthFailed("Server doesn't known any supported authentication method")
-        return connection, headers
-
-    def ntlmAuth(self, connection, headers):
-        self.logger.debug("Using NTLM authentication")
-        # Use ntlm
-        headers["Authorization"] = "Negotiate %s" % ntlm.create_NTLM_NEGOTIATE_MESSAGE(self.username, self.type1_flags)
-
-        connection.request("POST", self.url, headers=headers)
-        response = connection.getresponse()
-        response.read()
-        if response.status != 401:
-            raise HyperVAuthFailed("NTLM negotiation failed")
-
-        auth_header = response.getheader("WWW-Authenticate", "")
-        if auth_header == "":
-            raise HyperVAuthFailed("NTLM negotiation failed")
-
-        nego, challenge = auth_header.split(" ")
-        if nego != "Negotiate":
-            self.logger.warning("Wrong header: %s", auth_header)
-            raise HyperVAuthFailed("Wrong header: %s", auth_header)
-
-        nonce, flags = ntlm.parse_NTLM_CHALLENGE_MESSAGE(challenge)
-        headers["Authorization"] = "Negotiate %s" % ntlm.create_NTLM_AUTHENTICATE_MESSAGE(
-                    nonce, self.username, self.domainname, self.password, flags)
-
-        connection.request("POST", self.url, headers=headers)
-        response = connection.getresponse()
-        response.read()
-        if response.status == 200:
-            headers.pop("Authorization")
-            self.logger.debug("NTLM authentication successful")
-        else:
-            raise HyperVAuthFailed("NTLM negotiation failed")
-
-    def basicAuth(self, connection, headers):
-        self.logger.debug("Using Basic authentication")
-
-        passphrase = "%s:%s" % (self.username, self.password)
-        encoded = base64.encodestring(passphrase)
-        headers["Authorization"] = "Basic %s" % encoded.replace('\n', '')
+        s = requests.Session()
+        adapter = requests.adapters.HTTPAdapter(pool_connections=1, pool_maxsize=1)
+        s.mount('http://', adapter)
+        s.auth = HyperVAuth(self.username, self.password, self.logger)
+        return s
 
     @classmethod
     def decodeWinUUID(cls, uuid):
@@ -439,31 +507,29 @@ class HyperV(virt.Virt):
 
     def getHostGuestMapping(self):
         guests = []
-        connection, headers = self.connect()
-        hypervsoap = HyperVSoap(self.url, connection, headers, self.logger)
-        try:
-            if not self.useNewApi:
+        connection = self.connect()
+        hypervsoap = HyperVSoap(self.url, connection, self.logger)
+        if not self.useNewApi:
+            try:
                 # SettingType == 3 means current setting, 5 is snapshot - we don't want snapshots
                 uuid = hypervsoap.Enumerate(
                     "select BIOSGUID, ElementName "
                     "from Msvm_VirtualSystemSettingData "
                     "where SettingType = 3",
                     "root/virtualization")
-            else:
-                # Filter out Planned VMs and snapshots, see
-                # http://msdn.microsoft.com/en-us/library/hh850257%28v=vs.85%29.aspx
-                uuid = hypervsoap.Enumerate(
-                    "select BIOSGUID, ElementName "
-                    "from Msvm_VirtualSystemSettingData "
-                    "where VirtualSystemType = 'Microsoft:Hyper-V:System:Realized'",
-                    "root/virtualization/v2")
-        except HyperVException:
-            if not self.useNewApi:
-                self.logger.debug("Error when enumerating using root/virtualization namespace, "
+            except HyperVCallFailed:
+                self.logger.debug("Unable to enumerate using root/virtualization namespace, "
                                   "trying root/virtualization/v2 namespace")
                 self.useNewApi = True
-                return self.getHostGuestMapping()
-            raise
+
+        if self.useNewApi:
+            # Filter out Planned VMs and snapshots, see
+            # http://msdn.microsoft.com/en-us/library/hh850257%28v=vs.85%29.aspx
+            uuid = hypervsoap.Enumerate(
+                "select BIOSGUID, ElementName "
+                "from Msvm_VirtualSystemSettingData "
+                "where VirtualSystemType = 'Microsoft:Hyper-V:System:Realized'",
+                "root/virtualization/v2")
 
         # Get guest states
         guest_states = hypervsoap.Invoke_GetSummaryInformation(
diff --git a/virt/hyperv/ntlm.py b/virt/hyperv/ntlm.py
index c5220dc..54bb955 100644
--- a/virt/hyperv/ntlm.py
+++ b/virt/hyperv/ntlm.py
@@ -1,544 +1,527 @@
-# This library is free software: you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation, either
-# version 3 of the License, or (at your option) any later version.
-
-# This library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with this library.  If not, see <http://www.gnu.org/licenses/> or <http://www.gnu.org/licenses/lgpl.txt>.
 
+import os
 import struct
-import base64
-import string
+from socket import gethostname
 import subprocess
-
-try:
-    import hashlib
-    from hashlib import md5
-except ImportError:
-    from md5 import md5
-
-try:
-    from hashlib import algorithms
-except ImportError:
-    algorithms = []
-
 import hmac
-import random
-from socket import gethostname
-
-import M2Crypto
-
-
-# Use md4 from hashlib or directly from openssl
-class OpenSslMd4(object):
-    def __init__(self, data):
-        self.data = data
-
-    def digest(self):
-        return subprocess.Popen(["openssl", "md4", "-binary"], stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate(self.data)[0]
-
-
-class HashlibMd4(object):
-    def __init__(self, data):
-        self.md4 = hashlib.new('md4', data)
-
-    def digest(self):
-        return self.md4.digest()
-
-if 'md4' in algorithms:
-    md4 = HashlibMd4
-else:
-    md4 = OpenSslMd4
-
-
-# DES handling functions
-
-def des_encrypt(key_str, plain_text):
-    k = str_to_key56(key_str)
-    k = key56_to_key64(k)
-    key_str = ''
-    for i in k:
-        key_str += chr(i & 0xFF)
-    des = M2Crypto.EVP.Cipher("des_ecb", key=key_str, op=M2Crypto.encrypt, iv='\0' * 16)
-
-    return des.update(plain_text)
-
-
-def str_to_key56(key_str):
-    if len(key_str) < 7:
-        key_str = key_str + '\000\000\000\000\000\000\000'[:(7 - len(key_str))]
-    key_56 = []
-    for i in key_str[:7]:
-        key_56.append(ord(i))
-
-    return key_56
-
-
-def key56_to_key64(key_56):
-    ""
-    key = []
-    for i in range(8):
-        key.append(0)
-
-    key[0] = key_56[0]
-    key[1] = ((key_56[0] << 7) & 0xFF) | (key_56[1] >> 1)
-    key[2] = ((key_56[1] << 6) & 0xFF) | (key_56[2] >> 2)
-    key[3] = ((key_56[2] << 5) & 0xFF) | (key_56[3] >> 3)
-    key[4] = ((key_56[3] << 4) & 0xFF) | (key_56[4] >> 4)
-    key[5] = ((key_56[4] << 3) & 0xFF) | (key_56[5] >> 5)
-    key[6] = ((key_56[5] << 2) & 0xFF) | (key_56[6] >> 6)
-    key[7] = (key_56[6] << 1) & 0xFF
-
-    key = set_key_odd_parity(key)
-
-    return key
-
-
-def set_key_odd_parity(key):
-    ""
-    for i in range(len(key)):
-        for k in range(7):
-            bit = 0
-            t = key[i] >> k
-            bit = (t ^ bit) & 0x1
-        key[i] = (key[i] & 0xFE) | bit
-
-    return key
-
-# NTLM implemntation
-
-NTLM_NegotiateUnicode                =  0x00000001
-NTLM_NegotiateOEM                    =  0x00000002
-NTLM_RequestTarget                   =  0x00000004
-NTLM_Unknown9                        =  0x00000008
-NTLM_NegotiateSign                   =  0x00000010
-NTLM_NegotiateSeal                   =  0x00000020
-NTLM_NegotiateDatagram               =  0x00000040
-NTLM_NegotiateLanManagerKey          =  0x00000080
-NTLM_Unknown8                        =  0x00000100
-NTLM_NegotiateNTLM                   =  0x00000200
-NTLM_NegotiateNTOnly                 =  0x00000400
-NTLM_Anonymous                       =  0x00000800
-NTLM_NegotiateOemDomainSupplied      =  0x00001000
-NTLM_NegotiateOemWorkstationSupplied =  0x00002000
-NTLM_Unknown6                        =  0x00004000
-NTLM_NegotiateAlwaysSign             =  0x00008000
-NTLM_TargetTypeDomain                =  0x00010000
-NTLM_TargetTypeServer                =  0x00020000
-NTLM_TargetTypeShare                 =  0x00040000
-NTLM_NegotiateExtendedSecurity       =  0x00080000
-NTLM_NegotiateIdentify               =  0x00100000
-NTLM_Unknown5                        =  0x00200000
-NTLM_RequestNonNTSessionKey          =  0x00400000
-NTLM_NegotiateTargetInfo             =  0x00800000
-NTLM_Unknown4                        =  0x01000000
-NTLM_NegotiateVersion                =  0x02000000
-NTLM_Unknown3                        =  0x04000000
-NTLM_Unknown2                        =  0x08000000
-NTLM_Unknown1                        =  0x10000000
-NTLM_Negotiate128                    =  0x20000000
-NTLM_NegotiateKeyExchange            =  0x40000000
-NTLM_Negotiate56                     =  0x80000000
-
-# we send these flags with our type 1 message
-NTLM_TYPE1_FLAGS = (NTLM_NegotiateUnicode |
-                    NTLM_NegotiateOEM |
-                    NTLM_RequestTarget |
-                    NTLM_NegotiateNTLM |
-                    NTLM_NegotiateOemDomainSupplied |
-                    NTLM_NegotiateOemWorkstationSupplied |
-                    NTLM_NegotiateAlwaysSign |
-                    NTLM_NegotiateExtendedSecurity |
-                    NTLM_NegotiateVersion |
-                    NTLM_Negotiate128 |
-                    NTLM_Negotiate56)
-NTLM_TYPE2_FLAGS = (NTLM_NegotiateUnicode |
-                    NTLM_RequestTarget |
-                    NTLM_NegotiateNTLM |
-                    NTLM_NegotiateAlwaysSign |
-                    NTLM_NegotiateExtendedSecurity |
-                    NTLM_NegotiateTargetInfo |
-                    NTLM_NegotiateVersion |
-                    NTLM_Negotiate128 |
-                    NTLM_Negotiate56)
-
-NTLM_MsvAvEOL             = 0 # Indicates that this is the last AV_PAIR in the list. AvLen MUST be 0. This type of information MUST be present in the AV pair list.
-NTLM_MsvAvNbComputerName  = 1 # The server's NetBIOS computer name. The name MUST be in Unicode, and is not null-terminated. This type of information MUST be present in the AV_pair list.
-NTLM_MsvAvNbDomainName    = 2 # The server's NetBIOS domain name. The name MUST be in Unicode, and is not null-terminated. This type of information MUST be present in the AV_pair list.
-NTLM_MsvAvDnsComputerName = 3 # The server's Active Directory DNS computer name. The name MUST be in Unicode, and is not null-terminated.
-NTLM_MsvAvDnsDomainName   = 4 # The server's Active Directory DNS domain name. The name MUST be in Unicode, and is not null-terminated.
-NTLM_MsvAvDnsTreeName     = 5 # The server's Active Directory (AD) DNS forest tree name. The name MUST be in Unicode, and is not null-terminated.
-NTLM_MsvAvFlags           = 6 # A field containing a 32-bit value indicating server or client configuration. 0x00000001: indicates to the client that the account authentication is constrained. 0x00000002: indicates that the client is providing message integrity in the MIC field (section 2.2.1.3) in the AUTHENTICATE_MESSAGE.
-NTLM_MsvAvTimestamp       = 7 # A FILETIME structure ([MS-DTYP] section 2.3.1) in little-endian byte order that contains the server local time.<12>
-NTLM_MsAvRestrictions     = 8 # A Restriction_Encoding structure (section 2.2.2.2). The Value field contains a structure representing the integrity level of the security principal, as well as a MachineID created at computer startup to identify the calling machine. <13>
-
-
-"""
-utility functions for Microsoft NTLM authentication
-
-References:
-[MS-NLMP]: NT LAN Manager (NTLM) Authentication Protocol Specification
-http://download.microsoft.com/download/a/e/6/ae6e4142-aa58-45c6-8dcf-a657e5900cd3/%5BMS-NLMP%5D.pdf
-
-[MS-NTHT]: NTLM Over HTTP Protocol Specification
-http://download.microsoft.com/download/a/e/6/ae6e4142-aa58-45c6-8dcf-a657e5900cd3/%5BMS-NTHT%5D.pdf
-
-Cntlm Authentication Proxy
-http://cntlm.awk.cz/
-
-NTLM Authorization Proxy Server
-http://sourceforge.net/projects/ntlmaps/
-
-Optimized Attack for NTLM2 Session Response
-http://www.blackhat.com/presentations/bh-asia-04/bh-jp-04-pdfs/bh-jp-04-seki.pdf
-"""
-
-
-def dump_NegotiateFlags(NegotiateFlags):
-    if NegotiateFlags & NTLM_NegotiateUnicode:
-        print "NTLM_NegotiateUnicode set"
-    if NegotiateFlags & NTLM_NegotiateOEM:
-        print "NTLM_NegotiateOEM set"
-    if NegotiateFlags & NTLM_RequestTarget:
-        print "NTLM_RequestTarget set"
-    if NegotiateFlags & NTLM_Unknown9:
-        print "NTLM_Unknown9 set"
-    if NegotiateFlags & NTLM_NegotiateSign:
-        print "NTLM_NegotiateSign set"
-    if NegotiateFlags & NTLM_NegotiateSeal:
-        print "NTLM_NegotiateSeal set"
-    if NegotiateFlags & NTLM_NegotiateDatagram:
-        print "NTLM_NegotiateDatagram set"
-    if NegotiateFlags & NTLM_NegotiateLanManagerKey:
-        print "NTLM_NegotiateLanManagerKey set"
-    if NegotiateFlags & NTLM_Unknown8:
-        print "NTLM_Unknown8 set"
-    if NegotiateFlags & NTLM_NegotiateNTLM:
-        print "NTLM_NegotiateNTLM set"
-    if NegotiateFlags & NTLM_NegotiateNTOnly:
-        print "NTLM_NegotiateNTOnly set"
-    if NegotiateFlags & NTLM_Anonymous:
-        print "NTLM_Anonymous set"
-    if NegotiateFlags & NTLM_NegotiateOemDomainSupplied:
-        print "NTLM_NegotiateOemDomainSupplied set"
-    if NegotiateFlags & NTLM_NegotiateOemWorkstationSupplied:
-        print "NTLM_NegotiateOemWorkstationSupplied set"
-    if NegotiateFlags & NTLM_Unknown6:
-        print "NTLM_Unknown6 set"
-    if NegotiateFlags & NTLM_NegotiateAlwaysSign:
-        print "NTLM_NegotiateAlwaysSign set"
-    if NegotiateFlags & NTLM_TargetTypeDomain:
-        print "NTLM_TargetTypeDomain set"
-    if NegotiateFlags & NTLM_TargetTypeServer:
-        print "NTLM_TargetTypeServer set"
-    if NegotiateFlags & NTLM_TargetTypeShare:
-        print "NTLM_TargetTypeShare set"
-    if NegotiateFlags & NTLM_NegotiateExtendedSecurity:
-        print "NTLM_NegotiateExtendedSecurity set"
-    if NegotiateFlags & NTLM_NegotiateIdentify:
-        print "NTLM_NegotiateIdentify set"
-    if NegotiateFlags & NTLM_Unknown5:
-        print "NTLM_Unknown5 set"
-    if NegotiateFlags & NTLM_RequestNonNTSessionKey:
-        print "NTLM_RequestNonNTSessionKey set"
-    if NegotiateFlags & NTLM_NegotiateTargetInfo:
-        print "NTLM_NegotiateTargetInfo set"
-    if NegotiateFlags & NTLM_Unknown4:
-        print "NTLM_Unknown4 set"
-    if NegotiateFlags & NTLM_NegotiateVersion:
-        print "NTLM_NegotiateVersion set"
-    if NegotiateFlags & NTLM_Unknown3:
-        print "NTLM_Unknown3 set"
-    if NegotiateFlags & NTLM_Unknown2:
-        print "NTLM_Unknown2 set"
-    if NegotiateFlags & NTLM_Unknown1:
-        print "NTLM_Unknown1 set"
-    if NegotiateFlags & NTLM_Negotiate128:
-        print "NTLM_Negotiate128 set"
-    if NegotiateFlags & NTLM_NegotiateKeyExchange:
-        print "NTLM_NegotiateKeyExchange set"
-    if NegotiateFlags & NTLM_Negotiate56:
-        print "NTLM_Negotiate56 set"
-
-
-def create_NTLM_NEGOTIATE_MESSAGE(user, type1_flags=NTLM_TYPE1_FLAGS):
-    BODY_LENGTH = 40
-    Payload_start = BODY_LENGTH # in bytes
-    protocol = 'NTLMSSP\0' # name
-
-    type = struct.pack('<I', 1) # type 1
-
-    flags = struct.pack('<I', type1_flags)
-    Workstation = gethostname().upper().encode('ascii')
-    user_parts = user.split('\\', 1)
-    DomainName = user_parts[0].upper().encode('ascii')
-    EncryptedRandomSessionKey = ""
-
-    WorkstationLen = struct.pack('<H', len(Workstation))
-    WorkstationMaxLen = struct.pack('<H', len(Workstation))
-    WorkstationBufferOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(Workstation)
-    DomainNameLen = struct.pack('<H', len(DomainName))
-    DomainNameMaxLen = struct.pack('<H', len(DomainName))
-    DomainNameBufferOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(DomainName)
-    ProductMajorVersion = struct.pack('<B', 5)
-    ProductMinorVersion = struct.pack('<B', 1)
-    ProductBuild = struct.pack('<H', 2600)
-    VersionReserved1 = struct.pack('<B', 0)
-    VersionReserved2 = struct.pack('<B', 0)
-    VersionReserved3 = struct.pack('<B', 0)
-    NTLMRevisionCurrent = struct.pack('<B', 15)
-
-    msg1 = protocol + type + flags + \
-        DomainNameLen + DomainNameMaxLen + DomainNameBufferOffset + \
-        WorkstationLen + WorkstationMaxLen + WorkstationBufferOffset + \
-        ProductMajorVersion + ProductMinorVersion + ProductBuild + \
-        VersionReserved1 + VersionReserved2 + VersionReserved3 + NTLMRevisionCurrent
-    assert BODY_LENGTH == len(msg1), "BODY_LENGTH: %d != msg1: %d" % (BODY_LENGTH, len(msg1))
-    msg1 += Workstation + DomainName
-    msg1 = base64.encodestring(msg1)
-    msg1 = string.replace(msg1, '\n', '')
-    return msg1
-
-
-def parse_NTLM_CHALLENGE_MESSAGE(msg2):
-    ""
-    msg2 = base64.decodestring(msg2)
-    Signature = msg2[0:8]
-    msg_type = struct.unpack("<I", msg2[8:12])[0]
-    assert(msg_type == 2)
-    TargetNameLen = struct.unpack("<H", msg2[12:14])[0]
-    TargetNameMaxLen = struct.unpack("<H", msg2[14:16])[0]
-    TargetNameOffset = struct.unpack("<I", msg2[16:20])[0]
-    TargetName = msg2[TargetNameOffset:TargetNameOffset + TargetNameMaxLen]
-    NegotiateFlags = struct.unpack("<I", msg2[20:24])[0]
-    ServerChallenge = msg2[24:32]
-    Reserved = msg2[32:40]
-    TargetInfoLen = struct.unpack("<H", msg2[40:42])[0]
-    TargetInfoMaxLen = struct.unpack("<H", msg2[42:44])[0]
-    TargetInfoOffset = struct.unpack("<I", msg2[44:48])[0]
-    TargetInfo = msg2[TargetInfoOffset:TargetInfoOffset + TargetInfoLen]
-    i = 0
-    TimeStamp = '\0' * 8
-    while i < TargetInfoLen:
-        AvId = struct.unpack("<H", TargetInfo[i:i + 2])[0]
-        AvLen = struct.unpack("<H", TargetInfo[i + 2:i + 4])[0]
-        AvValue = TargetInfo[i + 4:i + 4 + AvLen]
-        i = i + 4 + AvLen
-        if AvId == NTLM_MsvAvTimestamp:
-            TimeStamp = AvValue
-    return (ServerChallenge, NegotiateFlags)
-
-
-def create_NTLM_AUTHENTICATE_MESSAGE(nonce, user, domain, password, NegotiateFlags):
-    ""
-    is_unicode = NegotiateFlags & NTLM_NegotiateUnicode
-    is_NegotiateExtendedSecurity = NegotiateFlags & NTLM_NegotiateExtendedSecurity
-
-    flags = struct.pack('<I', NTLM_TYPE2_FLAGS)
-
-    BODY_LENGTH = 72
-    Payload_start = BODY_LENGTH # in bytes
-
-    Workstation = gethostname().upper()
-    DomainName = domain.upper()
-    UserName = user
-    EncryptedRandomSessionKey = ""
-    if is_unicode:
-        Workstation = Workstation.encode('utf-16-le')
-        DomainName = DomainName.encode('utf-16-le')
-        UserName = UserName.encode('utf-16-le')
-        EncryptedRandomSessionKey = EncryptedRandomSessionKey.encode('utf-16-le')
-    LmChallengeResponse = calc_resp(create_LM_hashed_password_v1(password), nonce)
-    NtChallengeResponse = calc_resp(create_NT_hashed_password_v1(password), nonce)
-
-    if is_NegotiateExtendedSecurity:
-        pwhash = create_NT_hashed_password_v1(password, UserName, DomainName)
-        ClientChallenge = ""
-        for i in range(8):
-            ClientChallenge += chr(random.getrandbits(8))
-        (NtChallengeResponse, LmChallengeResponse) = ntlm2sr_calc_resp(pwhash, nonce, ClientChallenge) # ='\x39 e3 f4 cd 59 c5 d8 60')
-    Signature = 'NTLMSSP\0'
-    MessageType = struct.pack('<I', 3) # type 3
-
-    DomainNameLen = struct.pack('<H', len(DomainName))
-    DomainNameMaxLen = struct.pack('<H', len(DomainName))
-    DomainNameOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(DomainName)
-
-    UserNameLen = struct.pack('<H', len(UserName))
-    UserNameMaxLen = struct.pack('<H', len(UserName))
-    UserNameOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(UserName)
-
-    WorkstationLen = struct.pack('<H', len(Workstation))
-    WorkstationMaxLen = struct.pack('<H', len(Workstation))
-    WorkstationOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(Workstation)
-
-    LmChallengeResponseLen = struct.pack('<H', len(LmChallengeResponse))
-    LmChallengeResponseMaxLen = struct.pack('<H', len(LmChallengeResponse))
-    LmChallengeResponseOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(LmChallengeResponse)
-
-    NtChallengeResponseLen = struct.pack('<H', len(NtChallengeResponse))
-    NtChallengeResponseMaxLen = struct.pack('<H', len(NtChallengeResponse))
-    NtChallengeResponseOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(NtChallengeResponse)
-
-    EncryptedRandomSessionKeyLen = struct.pack('<H', len(EncryptedRandomSessionKey))
-    EncryptedRandomSessionKeyMaxLen = struct.pack('<H', len(EncryptedRandomSessionKey))
-    EncryptedRandomSessionKeyOffset = struct.pack('<I', Payload_start)
-    Payload_start += len(EncryptedRandomSessionKey)
-    NegotiateFlags = flags
-
-    ProductMajorVersion = struct.pack('<B', 5)
-    ProductMinorVersion = struct.pack('<B', 1)
-    ProductBuild = struct.pack('<H', 2600)
-    VersionReserved1 = struct.pack('<B', 0)
-    VersionReserved2 = struct.pack('<B', 0)
-    VersionReserved3 = struct.pack('<B', 0)
-    NTLMRevisionCurrent = struct.pack('<B', 15)
-
-    MIC = struct.pack('<IIII', 0, 0, 0, 0)
-    msg3 = Signature + MessageType + \
-        LmChallengeResponseLen + LmChallengeResponseMaxLen + LmChallengeResponseOffset + \
-        NtChallengeResponseLen + NtChallengeResponseMaxLen + NtChallengeResponseOffset + \
-        DomainNameLen + DomainNameMaxLen + DomainNameOffset + \
-        UserNameLen + UserNameMaxLen + UserNameOffset + \
-        WorkstationLen + WorkstationMaxLen + WorkstationOffset + \
-        EncryptedRandomSessionKeyLen + EncryptedRandomSessionKeyMaxLen + EncryptedRandomSessionKeyOffset + \
-        NegotiateFlags + \
-        ProductMajorVersion + ProductMinorVersion + ProductBuild + \
-        VersionReserved1 + VersionReserved2 + VersionReserved3 + NTLMRevisionCurrent
-    assert BODY_LENGTH == len(msg3), "BODY_LENGTH: %d != msg3: %d" % (BODY_LENGTH, len(msg3))
-    Payload = DomainName + UserName + Workstation + LmChallengeResponse + NtChallengeResponse + EncryptedRandomSessionKey
-    msg3 += Payload
-    msg3 = base64.encodestring(msg3)
-    msg3 = string.replace(msg3, '\n', '')
-    return msg3
-
-
-def calc_resp(password_hash, server_challenge):
-    """calc_resp generates the LM response given a 16-byte password hash and the
-        challenge from the Type-2 message.
-        @param password_hash
-            16-byte password hash
-        @param server_challenge
-            8-byte challenge from Type-2 message
-        returns
-            24-byte buffer to contain the LM response upon return
-    """
-    # padding with zeros to make the hash 21 bytes long
-    password_hash = password_hash + '\0' * (21 - len(password_hash))
-    return des_encrypt(password_hash[0: 7], server_challenge[0:8]) + \
-        des_encrypt(password_hash[7:14], server_challenge[0:8]) + \
-        des_encrypt(password_hash[14:21], server_challenge[0:8])
-
-
-def ComputeResponse(ResponseKeyNT, ResponseKeyLM, ServerChallenge, ServerName, ClientChallenge='\xaa' * 8, Time='\0' * 8):
-    LmChallengeResponse = hmac.new(ResponseKeyLM, ServerChallenge + ClientChallenge).digest() + ClientChallenge
-
-    Responserversion = '\x01'
-    HiResponserversion = '\x01'
-    temp = Responserversion + HiResponserversion + '\0' * 6 + Time + ClientChallenge + '\0' * 4 + ServerChallenge + '\0' * 4
-    NTProofStr = hmac.new(ResponseKeyNT, ServerChallenge + temp).digest()
-    NtChallengeResponse = NTProofStr + temp
-
-    SessionBaseKey = hmac.new(ResponseKeyNT, NTProofStr).digest()
-    return (NtChallengeResponse, LmChallengeResponse)
-
-
-def ntlm2sr_calc_resp(ResponseKeyNT, ServerChallenge, ClientChallenge='\xaa' * 8):
-    LmChallengeResponse = ClientChallenge + '\0' * 16
-    sess = md5(ServerChallenge + ClientChallenge).digest()
-    NtChallengeResponse = calc_resp(ResponseKeyNT, sess[0:8])
-    return (NtChallengeResponse, LmChallengeResponse)
-
-
-def create_LM_hashed_password_v1(passwd):
-    "setup LanManager password"
-    "create LanManager hashed password"
-
-    # fix the password length to 14 bytes
-    passwd = string.upper(passwd)
-    lm_pw = passwd + '\0' * (14 - len(passwd))
-    lm_pw = passwd[0:14]
-
-    # do hash
-    magic_str = "KGS!@#$%" # page 57 in [MS-NLMP]
-
-    return des_encrypt(lm_pw[0:7], magic_str) + des_encrypt(lm_pw[7:14], magic_str)
-
-
-def create_NT_hashed_password_v1(passwd, user=None, domain=None):
-    "create NT hashed password"
-    digest = md4(passwd.encode('utf-16le')).digest()
-    return digest
-
-
-def create_NT_hashed_password_v2(passwd, user, domain):
-    "create NT hashed password"
-    digest = create_NT_hashed_password_v1(passwd)
-
-    return hmac.new(digest, (user.upper() + domain).encode('utf-16le')).digest()
-
-
-def create_sessionbasekey(password):
-    return md4(create_NT_hashed_password_v1(password)).digest()
-
-
-if __name__ == "__main__":
-    def ByteToHex(byteStr):
-        """
-        Convert a byte string to it's hex string representation e.g. for output.
-        """
-        return ' '.join(["%02X" % ord(x) for x in byteStr])
-
-    def HexToByte(hexStr):
-        """
-        Convert a string hex byte values into a byte string. The Hex Byte values may
-        or may not be space separated.
-        """
-        bytes = []
-
-        hexStr = ''.join(hexStr.split(" "))
-
-        for i in range(0, len(hexStr), 2):
-            bytes.append(chr(int(hexStr[i:i + 2], 16)))
-
-        return ''.join(bytes)
-
-    ServerChallenge = HexToByte("01 23 45 67 89 ab cd ef")
-    ClientChallenge = '\xaa' * 8
-    Time = '\x00' * 8
-    Workstation = "COMPUTER".encode('utf-16-le')
-    ServerName = "Server".encode('utf-16-le')
-    User = "User"
-    Domain = "Domain"
-    Password = "Password"
-    RandomSessionKey = '\55' * 16
-    assert HexToByte("e5 2c ac 67 41 9a 9a 22 4a 3b 10 8f 3f a6 cb 6d") == create_LM_hashed_password_v1(Password)                  # [MS-NLMP] page 72
-    assert HexToByte("a4 f4 9c 40 65 10 bd ca b6 82 4e e7 c3 0f d8 52") == create_NT_hashed_password_v1(Password)    # [MS-NLMP] page 73
-    assert HexToByte("d8 72 62 b0 cd e4 b1 cb 74 99 be cc cd f1 07 84") == create_sessionbasekey(Password)
-    assert HexToByte("67 c4 30 11 f3 02 98 a2 ad 35 ec e6 4f 16 33 1c 44 bd be d9 27 84 1f 94") == calc_resp(create_NT_hashed_password_v1(Password), ServerChallenge)
-    assert HexToByte("98 de f7 b8 7f 88 aa 5d af e2 df 77 96 88 a1 72 de f1 1c 7d 5c cd ef 13") == calc_resp(create_LM_hashed_password_v1(Password), ServerChallenge)
-
-    (NTLMv1Response, LMv1Response) = ntlm2sr_calc_resp(create_NT_hashed_password_v1(Password), ServerChallenge, ClientChallenge)
-    assert HexToByte("aa aa aa aa aa aa aa aa 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00") == LMv1Response  # [MS-NLMP] page 75
-    assert HexToByte("75 37 f8 03 ae 36 71 28 ca 45 82 04 bd e7 ca f8 1e 97 ed 26 83 26 72 32") == NTLMv1Response
-
-    assert HexToByte("0c 86 8a 40 3b fd 7a 93 a3 00 1e f2 2e f0 2e 3f") == create_NT_hashed_password_v2(Password, User, Domain)    # [MS-NLMP] page 76
-    ResponseKeyLM = ResponseKeyNT = create_NT_hashed_password_v2(Password, User, Domain)
-    (NTLMv2Response, LMv2Response) = ComputeResponse(ResponseKeyNT, ResponseKeyLM, ServerChallenge, ServerName, ClientChallenge, Time)
-    assert HexToByte("86 c3 50 97 ac 9c ec 10 25 54 76 4a 57 cc cc 19 aa aa aa aa aa aa aa aa") == LMv2Response  # [MS-NLMP] page 76
-
-    # expected failure
-    # According to the spec in section '3.3.2 NTLM v2 Authentication' the NTLMv2Response should be longer than the value given on page 77 (this suggests a mistake in the spec)
-    # ~ assert HexToByte("68 cd 0a b8 51 e5 1c 96 aa bc 92 7b eb ef 6a 1c") == NTLMv2Response, "\nExpected: 68 cd 0a b8 51 e5 1c 96 aa bc 92 7b eb ef 6a 1c\nActual:   %s" % ByteToHex(NTLMv2Response) # [MS-NLMP] page 77
+import hashlib
+from M2Crypto.RC4 import RC4
+
+
+def rc4k(key, message):
+    '''
+    Compute rc4 of `message` with initial `key`.
+    '''
+    return RC4(key).update(message)
+
+
+def mac(handle, signing_key, seq_num, message):
+    '''
+    MAC signing method that create signature for given `message` with sequence
+    number `seq_num` and using key `signing_key`. The `handle` corresponds to
+    current state of sealing key.
+    '''
+    hmac_md5 = hmac.new(signing_key, struct.pack('<I', seq_num) + message).digest()[:8]
+    checksum = handle.update(hmac_md5)
+    return struct.pack('<I8sI', 1, checksum[:8], seq_num)
+
+
+def nonce(bytes):
+    '''
+    Random data with length of `bytes`.
+    '''
+    return os.urandom(bytes)
+
+
+def ntlm_compute_response(flags, response_key_nt, response_key_lm,
+                          server_challenge, client_challenge, time, target_info):
+    '''
+    Compute NTLMv2 response.
+
+    Return tuple (nt_challenge_response, lm_challenge_response, session_base_key).
+    '''
+    responser_version = '\x01'
+    hi_responser_version = '\x01'
+    temp = (
+        responser_version + hi_responser_version + '\0' * 6 + time +
+        client_challenge + '\0' * 4 + target_info + '\0' * 4
+    )
+    nt_proof_str = hmac.new(response_key_nt, server_challenge + temp).digest()
+    nt_challenge_response = nt_proof_str + temp
+    lm_challenge_response = hmac.new(response_key_lm, server_challenge + client_challenge).digest() + client_challenge
+    session_base_key = hmac.new(response_key_nt, nt_proof_str).digest()
+    return (nt_challenge_response, lm_challenge_response, session_base_key)
+
+
+def ntowfv2(passwd, user, domain):
+    '''
+    Hash password `passwd` using `user` and `domain`.
+    '''
+    return hmac.new(
+        hashlib.new('md4', passwd.encode('utf-16le')).digest(),
+        (user.upper() + domain).encode('utf-16le')
+    ).digest()
+
+
+class NtlmError(Exception):
+    pass
+
+
+# Session keys for NTLM
+SESSION_C2S_SEAL = 'session key to client-to-server sealing key magic constant\x00'
+SESSION_S2C_SEAL = 'session key to server-to-client sealing key magic constant\x00'
+SESSION_C2S_SIGN = 'session key to client-to-server signing key magic constant\x00'
+SESSION_S2C_SIGN = 'session key to server-to-client signing key magic constant\x00'
+
+# NTLM Flags
+NTLM_NegotiateUnicode = 0x00000001
+NTLM_NegotiateOEM = 0x00000002
+NTLM_RequestTarget = 0x00000004
+NTLM_Unknown9 = 0x00000008
+NTLM_NegotiateSign = 0x00000010
+NTLM_NegotiateSeal = 0x00000020
+NTLM_NegotiateDatagram = 0x00000040
+NTLM_NegotiateLanManagerKey = 0x00000080
+NTLM_Unknown8 = 0x00000100
+NTLM_NegotiateNTLM = 0x00000200
+NTLM_NegotiateNTOnly = 0x00000400
+NTLM_Anonymous = 0x00000800
+NTLM_NegotiateOemDomainSupplied = 0x00001000
+NTLM_NegotiateOemWorkstationSupplied = 0x00002000
+NTLM_Unknown6 = 0x00004000
+NTLM_NegotiateAlwaysSign = 0x00008000
+NTLM_TargetTypeDomain = 0x00010000
+NTLM_TargetTypeServer = 0x00020000
+NTLM_TargetTypeShare = 0x00040000
+NTLM_NegotiateExtendedSecurity = 0x00080000
+NTLM_NegotiateIdentify = 0x00100000
+NTLM_Unknown5 = 0x00200000
+NTLM_RequestNonNTSessionKey = 0x00400000
+NTLM_NegotiateTargetInfo = 0x00800000
+NTLM_Unknown4 = 0x01000000
+NTLM_NegotiateVersion = 0x02000000
+NTLM_Unknown3 = 0x04000000
+NTLM_Unknown2 = 0x08000000
+NTLM_Unknown1 = 0x10000000
+NTLM_Negotiate128 = 0x20000000
+NTLM_NegotiateKeyExchange = 0x40000000
+NTLM_Negotiate56 = 0x80000000
+
+
+class Message(object):
+    '''
+    Abstract message for NTLM authentication.
+    '''
+    VERSION = [
+        ('product_major_version', '<B'),
+        ('product_minor_version', '<B'),
+        ('product_build', '<H'),
+        ('reserved', '<B'),
+        ('reserved', '<B'),
+        ('reserved', '<B'),
+        ('ntlm_revision_current', '<B'),
+    ]
+
+    DEFAULTS = {
+        'signature': 'NTLMSSP\0',
+        'product_major_version': 5,
+        'product_minor_version': 1,
+        'product_build': 2600,
+        'reserved': 0,
+        'ntlm_revision_current': 15,
+    }
+
+
+class IncomingMessage(Message):
+    '''
+    Abstract incoming NTLM message.
+    '''
+    def __init__(self, message):
+        self._items = {}
+        self.payload = None
+        self._parse(message)
+
+    def _parse(self, message):
+        offset = 0
+        for name, signature in self.FORMAT:
+            self._items[name] = struct.unpack_from(signature, message, offset)[0]
+            offset += struct.calcsize(signature)
+        self.payload = message[offset:]
+
+    def __getattr__(self, name):
+        try:
+            return self._items[name]
+        except KeyError:
+            return Message.__getattr__(self, name)
+
+
+class OutgoingMessage(Message):
+    '''
+    Abstract outgoing NTLM message.
+    '''
+    def __init__(self, params):
+        self.params = params
+
+    def _format(self):
+        message = []
+        for name, signature in self.FORMAT:
+            item = self.params.get(name)
+            if item is None:
+                item = self.DEFAULTS[name]
+            message.append(struct.pack(signature, item))
+        return ''.join(message)
+
+    @property
+    def data(self):
+        return self._format()
+
+
+class NegotiateMessage(OutgoingMessage):
+    '''
+    NegotiateMessage is first message (sent by client) to initiate NTLM auth.
+    '''
+    HEADER_LENGTH = 40
+    FORMAT = [
+        ('signature', '8s'),
+        ('message_type', '<I'),
+        ('negotiate_flags', '<I'),
+        ('domain_name_len', '<H'),
+        ('domain_name_len', '<H'),
+        ('domain_name_buffer_offset', '<I'),
+        ('workstation_len', '<H'),
+        ('workstation_len', '<H'),
+        ('workstation_buffer_offset', '<I'),
+    ] + OutgoingMessage.VERSION
+    DEFAULTS = OutgoingMessage.DEFAULTS.copy()
+    DEFAULTS.update({
+        'message_type': 0x00000001,
+        'negotiate_flags': (
+            NTLM_NegotiateUnicode |
+            NTLM_NegotiateOEM |
+            NTLM_RequestTarget |
+            NTLM_NegotiateNTLM |
+            NTLM_NegotiateOemWorkstationSupplied |
+            NTLM_NegotiateAlwaysSign |
+            NTLM_NegotiateSign |
+            NTLM_NegotiateSeal |
+            NTLM_NegotiateExtendedSecurity |
+            NTLM_NegotiateVersion |
+            NTLM_Negotiate128 |
+            NTLM_Negotiate56 |
+            NTLM_NegotiateKeyExchange
+        ),
+    })
+
+    def __init__(self, domain, workstation, flags=None):
+        self.domain = domain
+        self.workstation = workstation
+        self.flags = flags
+
+    def _format(self):
+        domain_len = len(self.domain)
+        domain_offset = self.HEADER_LENGTH
+        workstation_len = len(self.workstation)
+        workstation_offset = domain_offset + domain_len
+        self.params = {
+            'domain_name_len': domain_len,
+            'domain_name_buffer_offset': domain_offset,
+            'workstation_len': workstation_len,
+            'workstation_buffer_offset': workstation_offset
+        }
+        if self.flags is not None:
+            self.params['negotiate_flags'] = self.flags
+        else:
+            self.params['negotiate_flags'] = self.DEFAULTS['negotiate_flags']
+        if domain_len > 0:
+            self.params['negotiate_flags'] |= NTLM_NegotiateOemDomainSupplied
+        return OutgoingMessage._format(self) + self.domain + self.workstation
+
+
+class ChallengeMessage(IncomingMessage):
+    '''
+    ChallengeMessage is send by server to provide data for NTLM authentication
+    and sealing.
+    '''
+    FORMAT = (
+        ('signature', '8s'),
+        ('message_type', '<I'),
+        ('target_name_len', '<H'),
+        ('target_name_len_max', '<H'),
+        ('target_name_buffer_offset', '<I'),
+        ('negotiate_flags', '<I'),
+        ('server_challenge', '8s'),
+        ('reserved', '8s'),
+        ('target_info_len', '<H'),
+        ('target_info_len_max', '<H'),
+        ('target_info_buffer_offset', '<I'),
+        ('version', '8s'),
+        # Payload (variable)
+    )
+
+    def _parse(self, message):
+        IncomingMessage._parse(self, message)
+        assert self._items['signature'] == 'NTLMSSP\x00'
+        assert self._items['message_type'] == 2
+        self._items['target_name'] = message[
+            self._items['target_name_buffer_offset']:
+            self._items['target_name_buffer_offset'] + self._items['target_name_len']]
+        self._items['target_info'] = message[
+            self._items['target_info_buffer_offset']:
+            self._items['target_info_buffer_offset'] + self._items['target_info_len']]
+        flags = self._items['negotiate_flags']
+        for flag in (NTLM_NegotiateUnicode, NTLM_NegotiateExtendedSecurity, NTLM_Negotiate128):
+            if not flag & flags:
+                raise NtlmError("NTLM negotiation failed, no flag %d" % flag)
+
+
+class AuthenticationMessage(OutgoingMessage):
+    '''
+    AuthenticateMessage is final message that the client sends. It contains
+    encrypted session key and other data used by authentication and sealing.
+    '''
+    HEADER_LENGTH = 72
+    FORMAT = [
+        ('signature', '8s'),
+        ('message_type', '<I'),
+        ('lm_challenge_response_len', '<H'),
+        ('lm_challenge_response_len', '<H'),
+        ('lm_challenge_response_buffer_offset', '<I'),
+        ('nt_challenge_response_len', '<H'),
+        ('nt_challenge_response_len', '<H'),
+        ('nt_challenge_response_buffer_offset', '<I'),
+        ('domain_name_len', '<H'),
+        ('domain_name_len', '<H'),
+        ('domain_name_buffer_offset', '<I'),
+        ('user_name_len', '<H'),
+        ('user_name_len', '<H'),
+        ('user_name_buffer_offset', '<I'),
+        ('workstation_len', '<H'),
+        ('workstation_len', '<H'),
+        ('workstation_buffer_offset', '<I'),
+        ('encrypted_random_session_key_len', '<H'),
+        ('encrypted_random_session_key_len', '<H'),
+        ('encrypted_random_session_key_buffer_offset', '<I'),
+        ('negotiate_flags', '<I'),
+    ] + OutgoingMessage.VERSION
+    DEFAULTS = OutgoingMessage.DEFAULTS.copy()
+    DEFAULTS.update({
+        'message_type': 0x00000003,
+        'negotiate_flags': (
+            NTLM_NegotiateKeyExchange |
+            NTLM_Negotiate128 |
+            NTLM_Negotiate56 |
+            NTLM_NegotiateVersion |
+            NTLM_NegotiateTargetInfo |
+            NTLM_NegotiateExtendedSecurity |
+            NTLM_NegotiateUnicode |
+            NTLM_NegotiateSign |
+            NTLM_NegotiateSeal |
+            NTLM_NegotiateNTLM |
+            NTLM_NegotiateAlwaysSign |
+            NTLM_RequestTarget
+        ),
+    })
+
+    def __init__(self, username, password, domain, workstation, server_challenge,
+                 target_info, negotiate_flags, client_challenge=None,
+                 exported_session_key=None):
+        self.username = username
+        self.password = password
+        self.domain = domain
+        self.workstation = workstation
+        self.server_challenge = server_challenge
+        self.target_info = target_info
+        self.time = self._time_from_target_info(target_info)
+        self.negotiate_flags = negotiate_flags
+        if client_challenge is not None:
+            self.client_challenge = client_challenge
+        else:
+            self.client_challenge = nonce(8)
+        if exported_session_key is not None:
+            self.exported_session_key = exported_session_key
+        else:
+            self.exported_session_key = nonce(16)
+
+        self._compute_encryption_data()
+
+    def _compute_encryption_data(self):
+        '''
+        Compute data that are needed for authentication and encryption.
+        '''
+        time = self.time or '\0' * 8
+
+        response_key_nt = response_key_lm = ntowfv2(self.password, self.username, self.domain)
+        self.nt_challenge_response, self.lm_challenge_response, session_base_key = ntlm_compute_response(
+            self.negotiate_flags, response_key_nt, response_key_lm,
+            self.server_challenge, self.client_challenge, time, self.target_info)
+
+        if self.time:
+            # Send NULLs instead of lm_challenge_response if we have time from server
+            self.lm_challenge_response = '\0' * 24
+
+        key_exchange_key = session_base_key  # key_exchange_key is always session_base_key in NTLMv2
+        if self.negotiate_flags & NTLM_NegotiateKeyExchange:
+            exported_session_key = self.exported_session_key
+            self.encrypted_random_session_key = rc4k(key_exchange_key, exported_session_key)
+        else:
+            exported_session_key = key_exchange_key
+            self.encrypted_random_session_key = ''
+
+        # The NTLM_NegotiateExtendedSecurity flag is always set
+        if NTLM_Negotiate128 & self.negotiate_flags:
+            self.session_key = exported_session_key
+        elif NTLM_Negotiate56 & self.negotiate_flags:
+            self.session_key = exported_session_key[:7]
+        else:
+            self.session_key = exported_session_key[:4]
+
+    def _time_from_target_info(self, target_info):
+        '''
+        Extract timestamp from target_info.
+        '''
+        l = len(target_info)
+        offset = 0
+        timestamp = None
+        while offset < l:
+            av_id = struct.unpack_from('<H', target_info, offset)[0]
+            offset += 2
+            av_len = struct.unpack_from('<H', target_info, offset)[0]
+            offset += 2
+            if av_id == '0x0007':  # Timestamp
+                timestamp = target_info[offset:offset + av_len]
+            offset += av_len
+        return timestamp
+
+    def _format(self):
+        username = self.username.encode('utf-16-le')
+        domain = self.domain.encode('utf-16-le')
+        workstation = self.workstation.encode('utf-16-le')
+        domain_len = len(domain)
+        domain_offset = self.HEADER_LENGTH
+        username_len = len(username)
+        username_offset = domain_offset + domain_len
+        workstation_len = len(workstation)
+        workstation_offset = username_offset + username_len
+
+        lm_challenge_response_len = len(self.lm_challenge_response)
+        lm_challenge_response_offset = workstation_offset + workstation_len
+
+        nt_challenge_response_len = len(self.nt_challenge_response)
+        nt_challenge_response_offset = lm_challenge_response_offset + lm_challenge_response_len
+
+        encrypted_random_session_key_len = len(self.encrypted_random_session_key)
+        encrypted_random_session_key_offset = nt_challenge_response_offset + nt_challenge_response_len
+        mic = '\0' * 16
+
+        flags = self.DEFAULTS['negotiate_flags']
+        self.params = {
+            'lm_challenge_response_len': lm_challenge_response_len,
+            'lm_challenge_response_buffer_offset': lm_challenge_response_offset,
+            'nt_challenge_response_len': nt_challenge_response_len,
+            'nt_challenge_response_buffer_offset': nt_challenge_response_offset,
+            'domain_name_len': domain_len,
+            'domain_name_buffer_offset': domain_offset,
+            'user_name_len': username_len,
+            'user_name_buffer_offset': username_offset,
+            'workstation_len': workstation_len,
+            'workstation_buffer_offset': workstation_offset,
+            'encrypted_random_session_key_len': encrypted_random_session_key_len,
+            'encrypted_random_session_key_buffer_offset': encrypted_random_session_key_offset,
+            'negotiate_flags': flags,
+            'mic': mic,
+        }
+        return (
+            OutgoingMessage._format(self) + domain + username + workstation +
+            self.lm_challenge_response + self.nt_challenge_response +
+            self.encrypted_random_session_key)
+
+
+class Ntlm(object):
+    '''
+    Wrapper for NTLM authentication and sealing.
+
+    Usage:
+    First call `negotiate_message` to create message of type 1 to be send
+    to server. Then server will respond with message of type 2. Supply it to
+    `authentication_message` as `challenge` argument together with `password`.
+    This method will return type 3 message that should be send to server
+    together with (possibly encrypted) data.
+
+    After these steps, you can encrypt and decrypt message using `encrypt`
+    and `decrypt` methods.
+    '''
+    def __init__(self):
+        self.incoming_seq_number = 0
+        self.outgoing_seq_number = 0
+
+    def negotiate_message(self, username):
+        '''
+        Create type 1 message to be send to server.
+        '''
+        user_parts = username.split('\\', 1)
+        if len(user_parts) > 1:
+            self.domain = user_parts[0].upper()
+            self.username = user_parts[1]
+        else:
+            self.domain = ''
+            self.username = username
+        self.workstation = gethostname().upper()
+        return NegotiateMessage(self.domain, self.workstation).data
+
+    def authentication_message(self, challenge, password):
+        '''
+        Create type 3 message from type 2 (`challenge` argument) and user
+        `password`.
+        '''
+        challenge = ChallengeMessage(challenge)
+        msg = AuthenticationMessage(
+            self.username, password, self.domain, self.workstation,
+            challenge.server_challenge, challenge.target_info,
+            challenge.negotiate_flags)
+
+        self.set_session_key(msg.session_key)
+        return msg.data
+
+    def set_session_key(self, session_key):
+        '''
+        Set session key that will be used for encryption and decryption.
+
+        If you call `authentication_message` you don't need to call this method.
+        '''
+        self.session_key = session_key
+
+        self.outgoing_sealing_key = hashlib.md5(session_key + SESSION_C2S_SEAL).digest()
+        self.incoming_sealing_key = hashlib.md5(session_key + SESSION_S2C_SEAL).digest()
+        self.outgoing_signing_key = hashlib.md5(session_key + SESSION_C2S_SIGN).digest()
+        self.incoming_signing_key = hashlib.md5(session_key + SESSION_S2C_SIGN).digest()
+
+        self.outgoing_seal_handle = RC4(self.outgoing_sealing_key)
+        self.incoming_seal_handle = RC4(self.incoming_sealing_key)
+
+    def encrypt(self, message):
+        '''
+        Encrypt and sign given `meesage` and return pair
+        (encrypted_message, signature).
+        '''
+        sealed_message = self.outgoing_seal_handle.update(message)
+        signature = mac(self.outgoing_seal_handle, self.outgoing_signing_key, self.outgoing_seq_number, message)
+        self.outgoing_seq_number += 1
+        return (sealed_message, signature)
+
+    def decrypt(self, sealed_message, signature):
+        '''
+        Decrypt `sealed_message` and check it signature. Return decrypted
+        message or Exception if sequence number or signature doesn't match.
+        '''
+        message = self.incoming_seal_handle.update(sealed_message)
+        version, checksum, sequence = struct.unpack('<I8sI', signature)
+        if sequence != self.incoming_seq_number:
+            raise Exception("Incorrect sequence number")
+        checksum = self.incoming_seal_handle.update(checksum)
+        expected_checksum = hmac.new(
+            self.incoming_signing_key,
+            struct.pack('<I', self.incoming_seq_number) + message).digest()[:8]
+        self.incoming_seq_number += 1
+        if checksum != expected_checksum:
+            raise Exception("Message has been altered")
+        return message
