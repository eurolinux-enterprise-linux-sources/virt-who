commit 14d397bb783d74907445fe854b7a156760df5be4
Author: Radek Novacek <rnovacek@redhat.com>
Date:   Tue Apr 21 12:59:02 2015 +0200

    fail before forking when password key does not exist

diff --git a/config.py b/config.py
index e6edff5..88a98bd 100644
--- a/config.py
+++ b/config.py
@@ -43,8 +43,7 @@ def parse_list(s):
 class Config(object):
     def __init__(self, name, type, server=None, username=None,
                  password=None, owner=None, env=None,
-                 rhsm_username=None, rhsm_password=None,
-                 encrypted_password=None, encrypted_rhsm_password=None):
+                 rhsm_username=None, rhsm_password=None):
 
         self._name = name
         self._type = type
@@ -56,12 +55,10 @@ class Config(object):
             self._server = server
         self._username = username
         self._password = password
-        self._encrypted_password = encrypted_password
         self._owner = owner
         self._env = env
         self._rhsm_username = rhsm_username
         self._rhsm_password = rhsm_password
-        self._encrypted_rhsm_password = encrypted_rhsm_password
 
         self.filter_host_uuids = []
         self.exclude_host_uuids = []
@@ -96,12 +93,11 @@ class Config(object):
         try:
             password = parser.get(name, "password")
         except NoOptionError:
-            password = None
-
-        try:
-            encrypted_password = parser.get(name, "encrypted_password")
-        except NoOptionError:
-            encrypted_password = None
+            try:
+                encrypted_password = parser.get(name, "encrypted_password")
+                password = Password.decrypt(unhexlify(encrypted_password))
+            except NoOptionError:
+                password = None
 
         try:
             owner = parser.get(name, "owner")
@@ -120,22 +116,16 @@ class Config(object):
         try:
             rhsm_password = parser.get(name, "rhsm_password")
         except NoOptionError:
-            rhsm_password = None
-
-        # Only attempt to get the encrypted rhsm password if we have a username:
-        encrypted_rhsm_password = None
-        if rhsm_username is not None and rhsm_password is None:
             try:
                 encrypted_rhsm_password = parser.get(name, "rhsm_encrypted_password")
+                rhsm_password = Password.decrypt(unhexlify(encrypted_rhsm_password))
             except NoOptionError:
-                pass
+                rhsm_password = None
 
         config = Config(name=name, type=type, server=server, username=username,
                         password=password, owner=owner, env=env,
                         rhsm_username=rhsm_username,
-                        rhsm_password=rhsm_password,
-                        encrypted_password=encrypted_password,
-                        encrypted_rhsm_password=encrypted_rhsm_password)
+                        rhsm_password=rhsm_password)
 
         try:
             config.hypervisor_id = parser.get(name, "hypervisor_id")
@@ -193,12 +183,7 @@ class Config(object):
 
     @property
     def password(self):
-        if self._password is not None:
-            return self._password
-        elif self._encrypted_password is not None:
-            return Password.decrypt(unhexlify(self._encrypted_password))
-        else:
-            return None
+        return self._password
 
     @property
     def owner(self):
@@ -214,12 +199,7 @@ class Config(object):
 
     @property
     def rhsm_password(self):
-        if self._rhsm_password is not None:
-            return self._rhsm_password
-        elif self._encrypted_rhsm_password is not None:
-            return Password.decrypt(unhexlify(self._encrypted_rhsm_password))
-        else:
-            return None
+        return self._rhsm_password
 
 
 class ConfigManager(object):
diff --git a/password/__init__.py b/password/__init__.py
index 9b3af79..1a072f7 100644
--- a/password/__init__.py
+++ b/password/__init__.py
@@ -71,8 +71,11 @@ class Password(object):
 
     @classmethod
     def decrypt(cls, enc):
-        key, iv = cls._read_key_iv()
-        return cls._unpad(cls._crypt(cls.DECRYPT, key, iv, enc))
+        try:
+            key, iv = cls._read_key_iv()
+            return cls._unpad(cls._crypt(cls.DECRYPT, key, iv, enc))
+        except TypeError:
+            raise InvalidKeyFile("Encryption key is invalid")
 
     @classmethod
     def _read_key_iv(cls):
diff --git a/tests/test_virtwho.py b/tests/test_virtwho.py
index 2e6cff1..4d06ce2 100644
--- a/tests/test_virtwho.py
+++ b/tests/test_virtwho.py
@@ -25,7 +25,7 @@ import logging
 
 from mock import patch, Mock
 
-from virtwho import parseOptions, VirtWho, OptionError
+from virtwho import parseOptions, VirtWho, OptionError, Queue
 from config import Config
 from virt import VirtError, HostGuestAssociationReport
 from manager import ManagerError
@@ -163,6 +163,7 @@ class TestOptions(TestBase):
         virtwho = VirtWho(self.logger, options, config_dir="/nonexistant")
         config = Config("test", "esx", "localhost", "username", "password", "owner", "env")
         virtwho.configManager.addConfig(config)
+        virtwho.queue = Queue()
         virtwho.queue.put(HostGuestAssociationReport(config, {'a': ['b']}))
         virtwho.run()
 
diff --git a/virtwho.py b/virtwho.py
index f6348a1..b8c17b7 100644
--- a/virtwho.py
+++ b/virtwho.py
@@ -31,6 +31,7 @@ from daemon import daemon
 from virt import Virt, DomainListReport, HostGuestAssociationReport
 from manager import Manager, ManagerError
 from config import Config, ConfigManager
+from password import InvalidKeyFile
 
 import log
 
@@ -80,8 +81,7 @@ class VirtWho(object):
         self.logger = logger
         self.options = options
         self.terminate_event = Event()
-        # Queue for getting events from virt backends
-        self.queue = Queue()
+        self.queue = None
 
         self.configManager = ConfigManager(config_dir)
         for config in self.configManager.configs:
@@ -134,6 +134,10 @@ class VirtWho(object):
         if not self.options.oneshot:
             self.logger.debug("Starting infinite loop with %d seconds interval" % self.options.interval)
 
+        # Queue for getting events from virt backends
+        if self.queue is None:
+            self.queue = Queue()
+
         # Run the virtualization backends
         self.virts = []
         for config in self.configManager.configs:
@@ -183,6 +187,7 @@ class VirtWho(object):
                 if oneshot_remaining == 0:
                     break
 
+        self.queue = None
         for virt in self.virts:
             virt.terminate()
         self.virts = []
@@ -474,7 +479,8 @@ def main():
 
     def atexit_fn():
         global virtWho
-        virtWho.terminate()
+        if virtWho:
+            virtWho.terminate()
     atexit.register(atexit_fn)
 
     def reload(signal, stackframe):
@@ -483,27 +489,16 @@ def main():
 
     signal.signal(signal.SIGHUP, reload)
 
-    if options.background:
-        locker = lambda: daemon.DaemonContext(pidfile=lock, files_preserve=[logger.handlers[0].stream])
-    else:
-        locker = lambda: lock
-
-    with locker():
-        while True:
-            try:
-                _main(logger, options)
-                break
-            except ReloadRequest:
-                logger.info("Reloading")
-                continue
-
-def _main(logger, options):
     global RetryInterval
     if options.interval < RetryInterval:
         RetryInterval = options.interval
 
     global virtWho
-    virtWho = VirtWho(logger, options)
+    try:
+        virtWho = VirtWho(logger, options)
+    except InvalidKeyFile as e:
+        logger.error(str(e))
+        sys.exit(1)
 
     if options.virtType is not None:
         config = Config("env/cmdline", options.virtType, options.server,
@@ -526,6 +521,21 @@ def _main(logger, options):
         else:
             logger.info('Using configuration "%s" ("%s" mode)', config.name, config.type)
 
+    if options.background:
+        locker = lambda: daemon.DaemonContext(pidfile=lock, files_preserve=[logger.handlers[0].stream])
+    else:
+        locker = lambda: lock
+
+    with locker():
+        while True:
+            try:
+                _main(virtWho)
+                break
+            except ReloadRequest:
+                logger.info("Reloading")
+                continue
+
+def _main(virtWho):
     result = virtWho.run()
 
     if virtWho.options.print_:
