commit 7398610d45c00756ffad9bd810cc2479ad6784e6
Author: Radek Novacek <rnovacek@redhat.com>
Date:   Thu Feb 25 16:29:02 2016 +0100

    Honor interval setting even with event monitoring

diff --git a/virt/esx/esx.py b/virt/esx/esx.py
index 8d4566f..f392a33 100644
--- a/virt/esx/esx.py
+++ b/virt/esx/esx.py
@@ -71,31 +71,23 @@ class Esx(virt.Virt):
         last_version = 'last_version'  # Bogus value so version != last_version from the start
         self.hosts = defaultdict(Host)
         self.vms = defaultdict(VM)
-        start_time = end_time = time()
         initial = True
+        next_update = time()
 
         while self._oneshot or not self.is_terminated():
-            delta = end_time - start_time
 
-            if initial:
+            delta = next_update - time()
+            if initial or delta < 0:
                 # We want to read the update asap
                 max_wait_seconds = 0
             else:
-                if delta - self._interval > 2.0:
-                    # The update took longer than it should, don't wait so long next time
-                    max_wait_seconds = max(self._interval - int(delta - self._interval), 0)
-                    self.logger.debug(
-                        "Getting the host/guests association took too long,"
-                        "interval waiting is shortened to %s", max_wait_seconds)
-                else:
-                    max_wait_seconds = self._interval
+                max_wait_seconds = int(delta)
 
             if version == '':
                 # also, clean all data we have
                 self.hosts.clear()
                 self.vms.clear()
 
-            start_time = time()
             try:
                 # Make sure that WaitForUpdatesEx finishes even
                 # if the ESX shuts down in the middle of waiting
@@ -116,7 +108,7 @@ class Esx(virt.Virt):
             except (suds.WebFault, HTTPException) as e:
                 suppress_exception = False
                 try:
-                    if e.fault.faultstring == 'The session is not authenticated.':
+                    if hasattr(e, 'fault') and e.fault.faultstring == 'The session is not authenticated.':
                         # Do not print the exception if we get 'not authenticated',
                         # it's quite normal behaviour and nothing to worry about
                         suppress_exception = True
@@ -127,7 +119,6 @@ class Esx(virt.Virt):
                 self._cancel_wait()
                 version = ''
                 self._prepare()
-                start_time = end_time = time()
                 continue
 
             if updateSet is not None:
@@ -137,18 +128,15 @@ class Esx(virt.Virt):
             if hasattr(updateSet, 'truncated') and updateSet.truncated:
                 continue
 
-            if last_version != version:
+            if last_version != version or time() > next_update:
                 assoc = self.getHostGuestMapping()
                 self.enqueue(virt.HostGuestAssociationReport(self.config, assoc))
+                next_update = time() + self._interval
                 last_version = version
 
-            end_time = time()
-
             if self._oneshot:
                 break
 
-            self.logger.debug("Waiting for ESX changes")
-
         self.cleanup()
 
     def cleanup(self):
diff --git a/virt/libvirtd/libvirtd.py b/virt/libvirtd/libvirtd.py
index 0d34b83..ecb9864 100644
--- a/virt/libvirtd/libvirtd.py
+++ b/virt/libvirtd/libvirtd.py
@@ -182,6 +182,7 @@ class Libvirtd(virt.Virt):
 
         self.virt = None
         initial = True
+        self.next_update = None
 
         while not self.is_terminated():
             if self.virt is None:
@@ -195,11 +196,17 @@ class Libvirtd(virt.Virt):
                 report = self._get_report()
                 self.enqueue(report)
                 initial = False
+                self.next_update = time.time() + self._interval
 
             if self._oneshot:
                 break
 
             time.sleep(1)
+            if time.time() > self.next_update:
+                report = self._get_report()
+                self.enqueue(report)
+                self.next_update = time.time() + self._interval
+
         if self.eventLoopThread is not None and self.eventLoopThread.isAlive():
             self.eventLoopThread.terminate()
             self.eventLoopThread.join(1)
@@ -208,6 +215,7 @@ class Libvirtd(virt.Virt):
     def _callback(self, *args, **kwargs):
         report = self._get_report()
         self.enqueue(report)
+        self.next_update = time.time() + self._interval
 
     def _get_report(self):
         if self.isHypervisor():
